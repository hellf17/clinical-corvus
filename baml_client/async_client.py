###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
from typing import Any, Dict, List, Optional, TypeVar, Union, TypedDict, Type, Literal, cast
from typing_extensions import NotRequired
import pprint

import baml_py
from pydantic import BaseModel, ValidationError, create_model

from . import partial_types, types
from .types import Checked, Check
from .type_builder import TypeBuilder
from .parser import LlmResponseParser, LlmStreamParser
from .async_request import AsyncHttpRequest, AsyncHttpStreamRequest
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX, DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME

OutputType = TypeVar('OutputType')


# Define the TypedDict with optional parameters having default values
class BamlCallOptions(TypedDict, total=False):
    tb: NotRequired[TypeBuilder]
    client_registry: NotRequired[baml_py.baml_py.ClientRegistry]
    collector: NotRequired[Union[baml_py.baml_py.Collector, List[baml_py.baml_py.Collector]]]


class BamlAsyncClient:
    __runtime: baml_py.BamlRuntime
    __ctx_manager: baml_py.BamlCtxManager
    __stream_client: "BamlStreamClient"
    __http_request: "AsyncHttpRequest"
    __http_stream_request: "AsyncHttpStreamRequest"
    __llm_response_parser: LlmResponseParser
    __llm_stream_parser: LlmStreamParser
    __baml_options: BamlCallOptions

    def __init__(self, runtime: baml_py.BamlRuntime, ctx_manager: baml_py.BamlCtxManager, baml_options: Optional[BamlCallOptions] = None):
      self.__runtime = runtime
      self.__ctx_manager = ctx_manager
      self.__stream_client = BamlStreamClient(self.__runtime, self.__ctx_manager, baml_options)
      self.__http_request = AsyncHttpRequest(self.__runtime, self.__ctx_manager)
      self.__http_stream_request = AsyncHttpStreamRequest(self.__runtime, self.__ctx_manager)
      self.__llm_response_parser = LlmResponseParser(self.__runtime, self.__ctx_manager)
      self.__llm_stream_parser = LlmStreamParser(self.__runtime, self.__ctx_manager)
      self.__baml_options = baml_options or {}

    def with_options(
      self,
      tb: Optional[TypeBuilder] = None,
      client_registry: Optional[baml_py.baml_py.ClientRegistry] = None,
      collector: Optional[Union[baml_py.baml_py.Collector, List[baml_py.baml_py.Collector]]] = None,
    ) -> "BamlAsyncClient":
      """
      Returns a new instance of BamlAsyncClient with explicitly typed baml options
      for Python 3.8 compatibility.
      """
      new_options = self.__baml_options.copy()

      # Override if any keyword arguments were provided.
      if tb is not None:
          new_options["tb"] = tb
      if client_registry is not None:
          new_options["client_registry"] = client_registry
      if collector is not None:
          new_options["collector"] = collector

      return BamlAsyncClient(self.__runtime, self.__ctx_manager, new_options)

    @property
    def stream(self):
      return self.__stream_client

    @property
    def request(self):
      return self.__http_request

    @property
    def stream_request(self):
      return self.__http_stream_request

    @property
    def parse(self):
      return self.__llm_response_parser

    @property
    def parse_stream(self):
      return self.__llm_stream_parser

    
    async def AnalyzeCiteSourceResults(
        self,
        input: types.CiteSourceAnalysisInput,
        baml_options: BamlCallOptions = {},
    ) -> types.CiteSourceAnalysisOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "AnalyzeCiteSourceResults",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.CiteSourceAnalysisOutput, raw.cast_to(types, types, partial_types, False))
    
    async def AnalyzeDifferentialDiagnoses_SNAPPS(
        self,
        input: types.AnalyzeDDxInput,
        baml_options: BamlCallOptions = {},
    ) -> types.DifferentialAnalysisOutputModel:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "AnalyzeDifferentialDiagnoses_SNAPPS",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.DifferentialAnalysisOutputModel, raw.cast_to(types, types, partial_types, False))
    
    async def AnalyzeMedicalPaper(
        self,
        paper_text: str,text_type: types.TextType,clinical_question: Optional[str],source_type: Optional[str],publication_year: Optional[int],
        baml_options: BamlCallOptions = {},
    ) -> types.EvidenceAnalysisData:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "AnalyzeMedicalPaper",
        {
          "paper_text": paper_text,"text_type": text_type,"clinical_question": clinical_question,"source_type": source_type,"publication_year": publication_year,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.EvidenceAnalysisData, raw.cast_to(types, types, partial_types, False))
    
    async def AnalyzePDFDocument(
        self,
        input: types.PDFAnalysisInput,
        baml_options: BamlCallOptions = {},
    ) -> types.PDFAnalysisOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "AnalyzePDFDocument",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.PDFAnalysisOutput, raw.cast_to(types, types, partial_types, False))
    
    async def AnswerProbeQuestions_SNAPPS(
        self,
        input: types.AnswerProbeQuestionsInput,
        baml_options: BamlCallOptions = {},
    ) -> types.ProbeResponseOutputModel:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "AnswerProbeQuestions_SNAPPS",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.ProbeResponseOutputModel, raw.cast_to(types, types, partial_types, False))
    
    async def AssistInIdentifyingCognitiveBiases(
        self,
        input: types.CognitiveBiasInput,
        baml_options: BamlCallOptions = {},
    ) -> types.CognitiveBiasReflectionOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "AssistInIdentifyingCognitiveBiases",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.CognitiveBiasReflectionOutput, raw.cast_to(types, types, partial_types, False))
    
    async def EvaluateManagementPlan_SNAPPS(
        self,
        input: types.EvaluateManagementPlanInput,
        baml_options: BamlCallOptions = {},
    ) -> types.PlanEvaluationOutputModel:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "EvaluateManagementPlan_SNAPPS",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.PlanEvaluationOutputModel, raw.cast_to(types, types, partial_types, False))
    
    async def EvaluateSummary_SNAPPS(
        self,
        input: types.EvaluateSummaryInput,
        baml_options: BamlCallOptions = {},
    ) -> types.SummaryFeedbackOutputModel:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "EvaluateSummary_SNAPPS",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.SummaryFeedbackOutputModel, raw.cast_to(types, types, partial_types, False))
    
    async def ExpandDifferentialDiagnosis(
        self,
        input: types.ExpandDifferentialDiagnosisInput,
        baml_options: BamlCallOptions = {},
    ) -> types.ExpandedDdxOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "ExpandDifferentialDiagnosis",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.ExpandedDdxOutput, raw.cast_to(types, types, partial_types, False))
    
    async def ExtractPubMedKeywords(
        self,
        complex_query: str,
        baml_options: BamlCallOptions = {},
    ) -> types.SimplifiedQueryOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "ExtractPubMedKeywords",
        {
          "complex_query": complex_query,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.SimplifiedQueryOutput, raw.cast_to(types, types, partial_types, False))
    
    async def FacilitateDDxAnalysis_SNAPPS(
        self,
        input: types.FacilitateDDxAnalysisInput,
        baml_options: BamlCallOptions = {},
    ) -> types.FacilitateDDxAnalysisOutputModel:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "FacilitateDDxAnalysis_SNAPPS",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.FacilitateDDxAnalysisOutputModel, raw.cast_to(types, types, partial_types, False))
    
    async def FormulateDeepResearchStrategy(
        self,
        input: types.ResearchTaskInput,
        baml_options: BamlCallOptions = {},
    ) -> types.FormulatedSearchStrategyOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "FormulateDeepResearchStrategy",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.FormulatedSearchStrategyOutput, raw.cast_to(types, types, partial_types, False))
    
    async def FormulateEvidenceBasedPICOQuestion(
        self,
        input: types.ClinicalScenarioInput,
        baml_options: BamlCallOptions = {},
    ) -> types.PICOFormulationOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "FormulateEvidenceBasedPICOQuestion",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.PICOFormulationOutput, raw.cast_to(types, types, partial_types, False))
    
    async def GenerateCiteSourceReport(
        self,
        input: types.CiteSourceReportInput,
        baml_options: BamlCallOptions = {},
    ) -> types.CiteSourceReportOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "GenerateCiteSourceReport",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.CiteSourceReportOutput, raw.cast_to(types, types, partial_types, False))
    
    async def GenerateClinicalWorkflowQuestions(
        self,
        input: types.DdxQuestioningInput,
        baml_options: BamlCallOptions = {},
    ) -> types.ClinicalWorkflowQuestionsOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "GenerateClinicalWorkflowQuestions",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.ClinicalWorkflowQuestionsOutput, raw.cast_to(types, types, partial_types, False))
    
    async def GenerateDiagnosticTimeout(
        self,
        input: types.DiagnosticTimeoutInput,
        baml_options: BamlCallOptions = {},
    ) -> types.DiagnosticTimeoutOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "GenerateDiagnosticTimeout",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.DiagnosticTimeoutOutput, raw.cast_to(types, types, partial_types, False))
    
    async def GenerateDrCorvusInsights(
        self,
        input: types.LabAnalysisInput,
        baml_options: BamlCallOptions = {},
    ) -> types.LabInsightsOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "GenerateDrCorvusInsights",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.LabInsightsOutput, raw.cast_to(types, types, partial_types, False))
    
    async def GenerateEvidenceAppraisal(
        self,
        extracted_data: types.EvidenceAnalysisData,clinical_question: Optional[str],
        baml_options: BamlCallOptions = {},
    ) -> types.EvidenceAppraisalOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "GenerateEvidenceAppraisal",
        {
          "extracted_data": extracted_data,"clinical_question": clinical_question,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.EvidenceAppraisalOutput, raw.cast_to(types, types, partial_types, False))
    
    async def GenerateIllnessScript(
        self,
        input: types.IllnessScriptInput,
        baml_options: BamlCallOptions = {},
    ) -> types.IllnessScriptOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "GenerateIllnessScript",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.IllnessScriptOutput, raw.cast_to(types, types, partial_types, False))
    
    async def OptimizeSearchStrategy(
        self,
        query: str,cite_source_metrics: types.CiteSourceMetrics,
        baml_options: BamlCallOptions = {},
    ) -> types.FormulatedSearchStrategyOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "OptimizeSearchStrategy",
        {
          "query": query,"cite_source_metrics": cite_source_metrics,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.FormulatedSearchStrategyOutput, raw.cast_to(types, types, partial_types, False))
    
    async def ProvideCompareContrastFeedback(
        self,
        input: types.CompareContrastExerciseInput,
        baml_options: BamlCallOptions = {},
    ) -> types.CompareContrastFeedbackOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "ProvideCompareContrastFeedback",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.CompareContrastFeedbackOutput, raw.cast_to(types, types, partial_types, False))
    
    async def ProvideFeedbackOnProblemRepresentation(
        self,
        input: types.BAMLProblemRepresentationInput,
        baml_options: BamlCallOptions = {},
    ) -> types.ProblemRepresentationFeedbackOutputModel:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "ProvideFeedbackOnProblemRepresentation",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.ProblemRepresentationFeedbackOutputModel, raw.cast_to(types, types, partial_types, False))
    
    async def ProvideMatrixFeedback(
        self,
        input: types.CompareContrastMatrixInput,
        baml_options: BamlCallOptions = {},
    ) -> types.MatrixFeedbackOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "ProvideMatrixFeedback",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.MatrixFeedbackOutput, raw.cast_to(types, types, partial_types, False))
    
    async def ProvideSelfReflectionFeedback(
        self,
        input: types.SelfReflectionInput,
        baml_options: BamlCallOptions = {},
    ) -> types.SelfReflectionFeedbackOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "ProvideSelfReflectionFeedback",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.SelfReflectionFeedbackOutput, raw.cast_to(types, types, partial_types, False))
    
    async def ProvideSessionSummary_SNAPPS(
        self,
        input: types.ProvideSessionSummaryInput,
        baml_options: BamlCallOptions = {},
    ) -> types.SessionSummaryOutputModel:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "ProvideSessionSummary_SNAPPS",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.SessionSummaryOutputModel, raw.cast_to(types, types, partial_types, False))
    
    async def SuggestPatientFriendlyFollowUpChecklist(
        self,
        input: types.PatientFollowUpInput,
        baml_options: BamlCallOptions = {},
    ) -> types.PatientFollowUpChecklistOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "SuggestPatientFriendlyFollowUpChecklist",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.PatientFollowUpChecklistOutput, raw.cast_to(types, types, partial_types, False))
    
    async def SummarizeAndStructureClinicalData(
        self,
        input: types.ClinicalDataInput,
        baml_options: BamlCallOptions = {},
    ) -> types.StructuredSummaryOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "SummarizeAndStructureClinicalData",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.StructuredSummaryOutput, raw.cast_to(types, types, partial_types, False))
    
    async def SynthesizeDeepResearch(
        self,
        original_query: str,search_results: List[types.RawSearchResultItem],
        baml_options: BamlCallOptions = {},
    ) -> types.SynthesizedResearchOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "SynthesizeDeepResearch",
        {
          "original_query": original_query,"search_results": search_results,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.SynthesizedResearchOutput, raw.cast_to(types, types, partial_types, False))
    
    async def SynthesizeDeepResearchMinimal(
        self,
        original_query: str,search_results: List[types.RawSearchResultItem],
        baml_options: BamlCallOptions = {},
    ) -> types.SynthesizedResearchOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "SynthesizeDeepResearchMinimal",
        {
          "original_query": original_query,"search_results": search_results,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.SynthesizedResearchOutput, raw.cast_to(types, types, partial_types, False))
    
    async def SynthesizeDeepResearchSimple(
        self,
        original_query: str,search_results: List[types.RawSearchResultItem],
        baml_options: BamlCallOptions = {},
    ) -> types.SynthesizedResearchOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "SynthesizeDeepResearchSimple",
        {
          "original_query": original_query,"search_results": search_results,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.SynthesizedResearchOutput, raw.cast_to(types, types, partial_types, False))
    
    async def TeachQuestionPrioritization(
        self,
        input: types.DdxQuestioningInput,
        baml_options: BamlCallOptions = {},
    ) -> types.DdxQuestioningOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "TeachQuestionPrioritization",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.DdxQuestioningOutput, raw.cast_to(types, types, partial_types, False))
    
    async def TranslateToEnglish(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.TranslationOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "TranslateToEnglish",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.TranslationOutput, raw.cast_to(types, types, partial_types, False))
    
    async def TranslateToPortuguese(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> types.TranslationOutput:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}

      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = await self.__runtime.call_function(
        "TranslateToPortuguese",
        {
          "input": input,
        },
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )
      return cast(types.TranslationOutput, raw.cast_to(types, types, partial_types, False))
    


class BamlStreamClient:
    __runtime: baml_py.BamlRuntime
    __ctx_manager: baml_py.BamlCtxManager
    __baml_options: BamlCallOptions
    def __init__(self, runtime: baml_py.BamlRuntime, ctx_manager: baml_py.BamlCtxManager, baml_options: Optional[BamlCallOptions] = None):
      self.__runtime = runtime
      self.__ctx_manager = ctx_manager
      self.__baml_options = baml_options or {}

    
    def AnalyzeCiteSourceResults(
        self,
        input: types.CiteSourceAnalysisInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.CiteSourceAnalysisOutput, types.CiteSourceAnalysisOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "AnalyzeCiteSourceResults",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.CiteSourceAnalysisOutput, types.CiteSourceAnalysisOutput](
        raw,
        lambda x: cast(partial_types.CiteSourceAnalysisOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.CiteSourceAnalysisOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def AnalyzeDifferentialDiagnoses_SNAPPS(
        self,
        input: types.AnalyzeDDxInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.DifferentialAnalysisOutputModel, types.DifferentialAnalysisOutputModel]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "AnalyzeDifferentialDiagnoses_SNAPPS",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.DifferentialAnalysisOutputModel, types.DifferentialAnalysisOutputModel](
        raw,
        lambda x: cast(partial_types.DifferentialAnalysisOutputModel, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.DifferentialAnalysisOutputModel, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def AnalyzeMedicalPaper(
        self,
        paper_text: str,text_type: types.TextType,clinical_question: Optional[str],source_type: Optional[str],publication_year: Optional[int],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.EvidenceAnalysisData, types.EvidenceAnalysisData]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "AnalyzeMedicalPaper",
        {
          "paper_text": paper_text,
          "text_type": text_type,
          "clinical_question": clinical_question,
          "source_type": source_type,
          "publication_year": publication_year,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.EvidenceAnalysisData, types.EvidenceAnalysisData](
        raw,
        lambda x: cast(partial_types.EvidenceAnalysisData, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.EvidenceAnalysisData, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def AnalyzePDFDocument(
        self,
        input: types.PDFAnalysisInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.PDFAnalysisOutput, types.PDFAnalysisOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "AnalyzePDFDocument",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.PDFAnalysisOutput, types.PDFAnalysisOutput](
        raw,
        lambda x: cast(partial_types.PDFAnalysisOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.PDFAnalysisOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def AnswerProbeQuestions_SNAPPS(
        self,
        input: types.AnswerProbeQuestionsInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.ProbeResponseOutputModel, types.ProbeResponseOutputModel]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "AnswerProbeQuestions_SNAPPS",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.ProbeResponseOutputModel, types.ProbeResponseOutputModel](
        raw,
        lambda x: cast(partial_types.ProbeResponseOutputModel, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.ProbeResponseOutputModel, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def AssistInIdentifyingCognitiveBiases(
        self,
        input: types.CognitiveBiasInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.CognitiveBiasReflectionOutput, types.CognitiveBiasReflectionOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "AssistInIdentifyingCognitiveBiases",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.CognitiveBiasReflectionOutput, types.CognitiveBiasReflectionOutput](
        raw,
        lambda x: cast(partial_types.CognitiveBiasReflectionOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.CognitiveBiasReflectionOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def EvaluateManagementPlan_SNAPPS(
        self,
        input: types.EvaluateManagementPlanInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.PlanEvaluationOutputModel, types.PlanEvaluationOutputModel]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "EvaluateManagementPlan_SNAPPS",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.PlanEvaluationOutputModel, types.PlanEvaluationOutputModel](
        raw,
        lambda x: cast(partial_types.PlanEvaluationOutputModel, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.PlanEvaluationOutputModel, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def EvaluateSummary_SNAPPS(
        self,
        input: types.EvaluateSummaryInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.SummaryFeedbackOutputModel, types.SummaryFeedbackOutputModel]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "EvaluateSummary_SNAPPS",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.SummaryFeedbackOutputModel, types.SummaryFeedbackOutputModel](
        raw,
        lambda x: cast(partial_types.SummaryFeedbackOutputModel, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.SummaryFeedbackOutputModel, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def ExpandDifferentialDiagnosis(
        self,
        input: types.ExpandDifferentialDiagnosisInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.ExpandedDdxOutput, types.ExpandedDdxOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "ExpandDifferentialDiagnosis",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.ExpandedDdxOutput, types.ExpandedDdxOutput](
        raw,
        lambda x: cast(partial_types.ExpandedDdxOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.ExpandedDdxOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def ExtractPubMedKeywords(
        self,
        complex_query: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.SimplifiedQueryOutput, types.SimplifiedQueryOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "ExtractPubMedKeywords",
        {
          "complex_query": complex_query,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.SimplifiedQueryOutput, types.SimplifiedQueryOutput](
        raw,
        lambda x: cast(partial_types.SimplifiedQueryOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.SimplifiedQueryOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def FacilitateDDxAnalysis_SNAPPS(
        self,
        input: types.FacilitateDDxAnalysisInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.FacilitateDDxAnalysisOutputModel, types.FacilitateDDxAnalysisOutputModel]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "FacilitateDDxAnalysis_SNAPPS",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.FacilitateDDxAnalysisOutputModel, types.FacilitateDDxAnalysisOutputModel](
        raw,
        lambda x: cast(partial_types.FacilitateDDxAnalysisOutputModel, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.FacilitateDDxAnalysisOutputModel, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def FormulateDeepResearchStrategy(
        self,
        input: types.ResearchTaskInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.FormulatedSearchStrategyOutput, types.FormulatedSearchStrategyOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "FormulateDeepResearchStrategy",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.FormulatedSearchStrategyOutput, types.FormulatedSearchStrategyOutput](
        raw,
        lambda x: cast(partial_types.FormulatedSearchStrategyOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.FormulatedSearchStrategyOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def FormulateEvidenceBasedPICOQuestion(
        self,
        input: types.ClinicalScenarioInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.PICOFormulationOutput, types.PICOFormulationOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "FormulateEvidenceBasedPICOQuestion",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.PICOFormulationOutput, types.PICOFormulationOutput](
        raw,
        lambda x: cast(partial_types.PICOFormulationOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.PICOFormulationOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def GenerateCiteSourceReport(
        self,
        input: types.CiteSourceReportInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.CiteSourceReportOutput, types.CiteSourceReportOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "GenerateCiteSourceReport",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.CiteSourceReportOutput, types.CiteSourceReportOutput](
        raw,
        lambda x: cast(partial_types.CiteSourceReportOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.CiteSourceReportOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def GenerateClinicalWorkflowQuestions(
        self,
        input: types.DdxQuestioningInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.ClinicalWorkflowQuestionsOutput, types.ClinicalWorkflowQuestionsOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "GenerateClinicalWorkflowQuestions",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.ClinicalWorkflowQuestionsOutput, types.ClinicalWorkflowQuestionsOutput](
        raw,
        lambda x: cast(partial_types.ClinicalWorkflowQuestionsOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.ClinicalWorkflowQuestionsOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def GenerateDiagnosticTimeout(
        self,
        input: types.DiagnosticTimeoutInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.DiagnosticTimeoutOutput, types.DiagnosticTimeoutOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "GenerateDiagnosticTimeout",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.DiagnosticTimeoutOutput, types.DiagnosticTimeoutOutput](
        raw,
        lambda x: cast(partial_types.DiagnosticTimeoutOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.DiagnosticTimeoutOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def GenerateDrCorvusInsights(
        self,
        input: types.LabAnalysisInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.LabInsightsOutput, types.LabInsightsOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "GenerateDrCorvusInsights",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.LabInsightsOutput, types.LabInsightsOutput](
        raw,
        lambda x: cast(partial_types.LabInsightsOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.LabInsightsOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def GenerateEvidenceAppraisal(
        self,
        extracted_data: types.EvidenceAnalysisData,clinical_question: Optional[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.EvidenceAppraisalOutput, types.EvidenceAppraisalOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "GenerateEvidenceAppraisal",
        {
          "extracted_data": extracted_data,
          "clinical_question": clinical_question,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.EvidenceAppraisalOutput, types.EvidenceAppraisalOutput](
        raw,
        lambda x: cast(partial_types.EvidenceAppraisalOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.EvidenceAppraisalOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def GenerateIllnessScript(
        self,
        input: types.IllnessScriptInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.IllnessScriptOutput, types.IllnessScriptOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "GenerateIllnessScript",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.IllnessScriptOutput, types.IllnessScriptOutput](
        raw,
        lambda x: cast(partial_types.IllnessScriptOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.IllnessScriptOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def OptimizeSearchStrategy(
        self,
        query: str,cite_source_metrics: types.CiteSourceMetrics,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.FormulatedSearchStrategyOutput, types.FormulatedSearchStrategyOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "OptimizeSearchStrategy",
        {
          "query": query,
          "cite_source_metrics": cite_source_metrics,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.FormulatedSearchStrategyOutput, types.FormulatedSearchStrategyOutput](
        raw,
        lambda x: cast(partial_types.FormulatedSearchStrategyOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.FormulatedSearchStrategyOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def ProvideCompareContrastFeedback(
        self,
        input: types.CompareContrastExerciseInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.CompareContrastFeedbackOutput, types.CompareContrastFeedbackOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "ProvideCompareContrastFeedback",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.CompareContrastFeedbackOutput, types.CompareContrastFeedbackOutput](
        raw,
        lambda x: cast(partial_types.CompareContrastFeedbackOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.CompareContrastFeedbackOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def ProvideFeedbackOnProblemRepresentation(
        self,
        input: types.BAMLProblemRepresentationInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.ProblemRepresentationFeedbackOutputModel, types.ProblemRepresentationFeedbackOutputModel]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "ProvideFeedbackOnProblemRepresentation",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.ProblemRepresentationFeedbackOutputModel, types.ProblemRepresentationFeedbackOutputModel](
        raw,
        lambda x: cast(partial_types.ProblemRepresentationFeedbackOutputModel, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.ProblemRepresentationFeedbackOutputModel, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def ProvideMatrixFeedback(
        self,
        input: types.CompareContrastMatrixInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.MatrixFeedbackOutput, types.MatrixFeedbackOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "ProvideMatrixFeedback",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.MatrixFeedbackOutput, types.MatrixFeedbackOutput](
        raw,
        lambda x: cast(partial_types.MatrixFeedbackOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.MatrixFeedbackOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def ProvideSelfReflectionFeedback(
        self,
        input: types.SelfReflectionInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.SelfReflectionFeedbackOutput, types.SelfReflectionFeedbackOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "ProvideSelfReflectionFeedback",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.SelfReflectionFeedbackOutput, types.SelfReflectionFeedbackOutput](
        raw,
        lambda x: cast(partial_types.SelfReflectionFeedbackOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.SelfReflectionFeedbackOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def ProvideSessionSummary_SNAPPS(
        self,
        input: types.ProvideSessionSummaryInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.SessionSummaryOutputModel, types.SessionSummaryOutputModel]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "ProvideSessionSummary_SNAPPS",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.SessionSummaryOutputModel, types.SessionSummaryOutputModel](
        raw,
        lambda x: cast(partial_types.SessionSummaryOutputModel, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.SessionSummaryOutputModel, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def SuggestPatientFriendlyFollowUpChecklist(
        self,
        input: types.PatientFollowUpInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.PatientFollowUpChecklistOutput, types.PatientFollowUpChecklistOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "SuggestPatientFriendlyFollowUpChecklist",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.PatientFollowUpChecklistOutput, types.PatientFollowUpChecklistOutput](
        raw,
        lambda x: cast(partial_types.PatientFollowUpChecklistOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.PatientFollowUpChecklistOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def SummarizeAndStructureClinicalData(
        self,
        input: types.ClinicalDataInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.StructuredSummaryOutput, types.StructuredSummaryOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "SummarizeAndStructureClinicalData",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.StructuredSummaryOutput, types.StructuredSummaryOutput](
        raw,
        lambda x: cast(partial_types.StructuredSummaryOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.StructuredSummaryOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def SynthesizeDeepResearch(
        self,
        original_query: str,search_results: List[types.RawSearchResultItem],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.SynthesizedResearchOutput, types.SynthesizedResearchOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "SynthesizeDeepResearch",
        {
          "original_query": original_query,
          "search_results": search_results,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.SynthesizedResearchOutput, types.SynthesizedResearchOutput](
        raw,
        lambda x: cast(partial_types.SynthesizedResearchOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.SynthesizedResearchOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def SynthesizeDeepResearchMinimal(
        self,
        original_query: str,search_results: List[types.RawSearchResultItem],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.SynthesizedResearchOutput, types.SynthesizedResearchOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "SynthesizeDeepResearchMinimal",
        {
          "original_query": original_query,
          "search_results": search_results,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.SynthesizedResearchOutput, types.SynthesizedResearchOutput](
        raw,
        lambda x: cast(partial_types.SynthesizedResearchOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.SynthesizedResearchOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def SynthesizeDeepResearchSimple(
        self,
        original_query: str,search_results: List[types.RawSearchResultItem],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.SynthesizedResearchOutput, types.SynthesizedResearchOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "SynthesizeDeepResearchSimple",
        {
          "original_query": original_query,
          "search_results": search_results,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.SynthesizedResearchOutput, types.SynthesizedResearchOutput](
        raw,
        lambda x: cast(partial_types.SynthesizedResearchOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.SynthesizedResearchOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def TeachQuestionPrioritization(
        self,
        input: types.DdxQuestioningInput,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.DdxQuestioningOutput, types.DdxQuestioningOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "TeachQuestionPrioritization",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.DdxQuestioningOutput, types.DdxQuestioningOutput](
        raw,
        lambda x: cast(partial_types.DdxQuestioningOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.DdxQuestioningOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def TranslateToEnglish(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.TranslationOutput, types.TranslationOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "TranslateToEnglish",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.TranslationOutput, types.TranslationOutput](
        raw,
        lambda x: cast(partial_types.TranslationOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.TranslationOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    
    def TranslateToPortuguese(
        self,
        input: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[partial_types.TranslationOutput, types.TranslationOutput]:
      options: BamlCallOptions = {**self.__baml_options, **(baml_options or {})}
      __tb__ = options.get("tb", None)
      if __tb__ is not None:
        tb = __tb__._tb # type: ignore (we know how to use this private attribute)
      else:
        tb = None
      __cr__ = options.get("client_registry", None)
      collector = options.get("collector", None)
      collectors = collector if isinstance(collector, list) else [collector] if collector is not None else []
      raw = self.__runtime.stream_function(
        "TranslateToPortuguese",
        {
          "input": input,
        },
        None,
        self.__ctx_manager.get(),
        tb,
        __cr__,
        collectors,
      )

      return baml_py.BamlStream[partial_types.TranslationOutput, types.TranslationOutput](
        raw,
        lambda x: cast(partial_types.TranslationOutput, x.cast_to(types, types, partial_types, True)),
        lambda x: cast(types.TranslationOutput, x.cast_to(types, types, partial_types, False)),
        self.__ctx_manager.get(),
      )
    


b = BamlAsyncClient(DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME, DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX)

__all__ = ["b"]