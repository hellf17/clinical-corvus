###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import typing
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder
from baml_py.type_builder import TypeBuilder as _TypeBuilder, ClassPropertyBuilder, ClassPropertyViewer, EnumValueViewer
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME


class TypeBuilder(_TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["AnalyzeDifferentialDiagnosesSNAPPSInput","AnswerProbeQuestionsSNAPPSInputModel","AnsweredQuestion","BAMLProblemRepresentationInput","BenchmarkComparison","BiasAnalysis","BiasReflectionPoint","CaseContext","CaseScenarioInput","CiteSourceAnalysisInput","CiteSourceAnalysisOutput","CiteSourceMetrics","CiteSourceReportInput","CiteSourceReportOutput","ClinicalDataInput","ClinicalFinding","ClinicalScenarioInput","ClinicalWorkflowQuestionsOutput","CognitiveBiasInput","CognitiveBiasReflectionOutput","CompareContrastExerciseInput","CompareContrastFeedbackOutput","DdxEvaluation","DdxQuestioningInput","DdxQuestioningOutput","DeduplicationAnalysis","DeduplicationSummary","DetectedCognitiveBias","DiagnosticTimeoutInput","DiagnosticTimeoutOutput","DifferentialAnalysisOutputModel","EvaluateManagementPlanSNAPPSInputModel","EvaluateSummarySNAPPSInputModel","EvidenceAnalysisData","EvidenceAppraisalOutput","EvidenceTheme","ExecutiveSummary","ExpandDifferentialDiagnosisInput","ExpandedDdxOutput","FacilitateDDxAnalysisOutputModel","FacilitateDDxAnalysisSNAPPSInputModel","FormulatedSearchStrategyOutput","HypothesisComparisonFeedback","IllnessScriptInput","IllnessScriptOutput","InterventionInfo","KeyResult","LabAnalysisInput","LabInsightsOutput","LabTestResult","PDFAnalysisInput","PDFAnalysisOutput","PICOFormulationOutput","PICOQuestion","PatientFollowUpChecklistOutput","PatientFollowUpInput","PlanEvaluationOutputModel","PopulationInfo","ProbeResponseOutputModel","ProblemRepresentationFeedbackOutputModel","ProcessingMetadata","ProvideSessionSummarySNAPPSInputModel","QualityFactor","QualityScores","QuestionCategory","RawSearchResultItem","ResearchMetrics","ResearchTaskInput","SearchParameters","SelfReflectionFeedbackOutput","SelfReflectionInput","SessionSummaryOutputModel","SimplifiedQueryOutput","SourceAnalysis","SourcePerformanceMetrics","StructuredSummaryOutput","StudentHypothesisAnalysis","SummaryFeedbackOutputModel","SynthesizedResearchOutput","TranslationOutput","VisualDataSummary",]
        ), enums=set(
          ["AssessmentValue","GradeLevel","PossibleCognitiveBias","RecommendationStrength","ResearchSourceType","StudyDesignType","StudyTypeFilter","UserRole",]
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)


    @property
    def AnalyzeDifferentialDiagnosesSNAPPSInput(self) -> "AnalyzeDifferentialDiagnosesSNAPPSInputAst":
        return AnalyzeDifferentialDiagnosesSNAPPSInputAst(self)

    @property
    def AnswerProbeQuestionsSNAPPSInputModel(self) -> "AnswerProbeQuestionsSNAPPSInputModelAst":
        return AnswerProbeQuestionsSNAPPSInputModelAst(self)

    @property
    def AnsweredQuestion(self) -> "AnsweredQuestionAst":
        return AnsweredQuestionAst(self)

    @property
    def BAMLProblemRepresentationInput(self) -> "BAMLProblemRepresentationInputAst":
        return BAMLProblemRepresentationInputAst(self)

    @property
    def BenchmarkComparison(self) -> "BenchmarkComparisonAst":
        return BenchmarkComparisonAst(self)

    @property
    def BiasAnalysis(self) -> "BiasAnalysisAst":
        return BiasAnalysisAst(self)

    @property
    def BiasReflectionPoint(self) -> "BiasReflectionPointAst":
        return BiasReflectionPointAst(self)

    @property
    def CaseContext(self) -> "CaseContextAst":
        return CaseContextAst(self)

    @property
    def CaseScenarioInput(self) -> "CaseScenarioInputAst":
        return CaseScenarioInputAst(self)

    @property
    def CiteSourceAnalysisInput(self) -> "CiteSourceAnalysisInputAst":
        return CiteSourceAnalysisInputAst(self)

    @property
    def CiteSourceAnalysisOutput(self) -> "CiteSourceAnalysisOutputAst":
        return CiteSourceAnalysisOutputAst(self)

    @property
    def CiteSourceMetrics(self) -> "CiteSourceMetricsAst":
        return CiteSourceMetricsAst(self)

    @property
    def CiteSourceReportInput(self) -> "CiteSourceReportInputAst":
        return CiteSourceReportInputAst(self)

    @property
    def CiteSourceReportOutput(self) -> "CiteSourceReportOutputAst":
        return CiteSourceReportOutputAst(self)

    @property
    def ClinicalDataInput(self) -> "ClinicalDataInputAst":
        return ClinicalDataInputAst(self)

    @property
    def ClinicalFinding(self) -> "ClinicalFindingAst":
        return ClinicalFindingAst(self)

    @property
    def ClinicalScenarioInput(self) -> "ClinicalScenarioInputAst":
        return ClinicalScenarioInputAst(self)

    @property
    def ClinicalWorkflowQuestionsOutput(self) -> "ClinicalWorkflowQuestionsOutputAst":
        return ClinicalWorkflowQuestionsOutputAst(self)

    @property
    def CognitiveBiasInput(self) -> "CognitiveBiasInputAst":
        return CognitiveBiasInputAst(self)

    @property
    def CognitiveBiasReflectionOutput(self) -> "CognitiveBiasReflectionOutputAst":
        return CognitiveBiasReflectionOutputAst(self)

    @property
    def CompareContrastExerciseInput(self) -> "CompareContrastExerciseInputAst":
        return CompareContrastExerciseInputAst(self)

    @property
    def CompareContrastFeedbackOutput(self) -> "CompareContrastFeedbackOutputAst":
        return CompareContrastFeedbackOutputAst(self)

    @property
    def DdxEvaluation(self) -> "DdxEvaluationAst":
        return DdxEvaluationAst(self)

    @property
    def DdxQuestioningInput(self) -> "DdxQuestioningInputAst":
        return DdxQuestioningInputAst(self)

    @property
    def DdxQuestioningOutput(self) -> "DdxQuestioningOutputAst":
        return DdxQuestioningOutputAst(self)

    @property
    def DeduplicationAnalysis(self) -> "DeduplicationAnalysisAst":
        return DeduplicationAnalysisAst(self)

    @property
    def DeduplicationSummary(self) -> "DeduplicationSummaryAst":
        return DeduplicationSummaryAst(self)

    @property
    def DetectedCognitiveBias(self) -> "DetectedCognitiveBiasAst":
        return DetectedCognitiveBiasAst(self)

    @property
    def DiagnosticTimeoutInput(self) -> "DiagnosticTimeoutInputAst":
        return DiagnosticTimeoutInputAst(self)

    @property
    def DiagnosticTimeoutOutput(self) -> "DiagnosticTimeoutOutputAst":
        return DiagnosticTimeoutOutputAst(self)

    @property
    def DifferentialAnalysisOutputModel(self) -> "DifferentialAnalysisOutputModelAst":
        return DifferentialAnalysisOutputModelAst(self)

    @property
    def EvaluateManagementPlanSNAPPSInputModel(self) -> "EvaluateManagementPlanSNAPPSInputModelAst":
        return EvaluateManagementPlanSNAPPSInputModelAst(self)

    @property
    def EvaluateSummarySNAPPSInputModel(self) -> "EvaluateSummarySNAPPSInputModelAst":
        return EvaluateSummarySNAPPSInputModelAst(self)

    @property
    def EvidenceAnalysisData(self) -> "EvidenceAnalysisDataAst":
        return EvidenceAnalysisDataAst(self)

    @property
    def EvidenceAppraisalOutput(self) -> "EvidenceAppraisalOutputAst":
        return EvidenceAppraisalOutputAst(self)

    @property
    def EvidenceTheme(self) -> "EvidenceThemeAst":
        return EvidenceThemeAst(self)

    @property
    def ExecutiveSummary(self) -> "ExecutiveSummaryAst":
        return ExecutiveSummaryAst(self)

    @property
    def ExpandDifferentialDiagnosisInput(self) -> "ExpandDifferentialDiagnosisInputAst":
        return ExpandDifferentialDiagnosisInputAst(self)

    @property
    def ExpandedDdxOutput(self) -> "ExpandedDdxOutputAst":
        return ExpandedDdxOutputAst(self)

    @property
    def FacilitateDDxAnalysisOutputModel(self) -> "FacilitateDDxAnalysisOutputModelAst":
        return FacilitateDDxAnalysisOutputModelAst(self)

    @property
    def FacilitateDDxAnalysisSNAPPSInputModel(self) -> "FacilitateDDxAnalysisSNAPPSInputModelAst":
        return FacilitateDDxAnalysisSNAPPSInputModelAst(self)

    @property
    def FormulatedSearchStrategyOutput(self) -> "FormulatedSearchStrategyOutputAst":
        return FormulatedSearchStrategyOutputAst(self)

    @property
    def HypothesisComparisonFeedback(self) -> "HypothesisComparisonFeedbackAst":
        return HypothesisComparisonFeedbackAst(self)

    @property
    def IllnessScriptInput(self) -> "IllnessScriptInputAst":
        return IllnessScriptInputAst(self)

    @property
    def IllnessScriptOutput(self) -> "IllnessScriptOutputAst":
        return IllnessScriptOutputAst(self)

    @property
    def InterventionInfo(self) -> "InterventionInfoAst":
        return InterventionInfoAst(self)

    @property
    def KeyResult(self) -> "KeyResultAst":
        return KeyResultAst(self)

    @property
    def LabAnalysisInput(self) -> "LabAnalysisInputAst":
        return LabAnalysisInputAst(self)

    @property
    def LabInsightsOutput(self) -> "LabInsightsOutputAst":
        return LabInsightsOutputAst(self)

    @property
    def LabTestResult(self) -> "LabTestResultAst":
        return LabTestResultAst(self)

    @property
    def PDFAnalysisInput(self) -> "PDFAnalysisInputAst":
        return PDFAnalysisInputAst(self)

    @property
    def PDFAnalysisOutput(self) -> "PDFAnalysisOutputAst":
        return PDFAnalysisOutputAst(self)

    @property
    def PICOFormulationOutput(self) -> "PICOFormulationOutputAst":
        return PICOFormulationOutputAst(self)

    @property
    def PICOQuestion(self) -> "PICOQuestionAst":
        return PICOQuestionAst(self)

    @property
    def PatientFollowUpChecklistOutput(self) -> "PatientFollowUpChecklistOutputAst":
        return PatientFollowUpChecklistOutputAst(self)

    @property
    def PatientFollowUpInput(self) -> "PatientFollowUpInputAst":
        return PatientFollowUpInputAst(self)

    @property
    def PlanEvaluationOutputModel(self) -> "PlanEvaluationOutputModelAst":
        return PlanEvaluationOutputModelAst(self)

    @property
    def PopulationInfo(self) -> "PopulationInfoAst":
        return PopulationInfoAst(self)

    @property
    def ProbeResponseOutputModel(self) -> "ProbeResponseOutputModelAst":
        return ProbeResponseOutputModelAst(self)

    @property
    def ProblemRepresentationFeedbackOutputModel(self) -> "ProblemRepresentationFeedbackOutputModelAst":
        return ProblemRepresentationFeedbackOutputModelAst(self)

    @property
    def ProcessingMetadata(self) -> "ProcessingMetadataAst":
        return ProcessingMetadataAst(self)

    @property
    def ProvideSessionSummarySNAPPSInputModel(self) -> "ProvideSessionSummarySNAPPSInputModelAst":
        return ProvideSessionSummarySNAPPSInputModelAst(self)

    @property
    def QualityFactor(self) -> "QualityFactorAst":
        return QualityFactorAst(self)

    @property
    def QualityScores(self) -> "QualityScoresAst":
        return QualityScoresAst(self)

    @property
    def QuestionCategory(self) -> "QuestionCategoryAst":
        return QuestionCategoryAst(self)

    @property
    def RawSearchResultItem(self) -> "RawSearchResultItemAst":
        return RawSearchResultItemAst(self)

    @property
    def ResearchMetrics(self) -> "ResearchMetricsAst":
        return ResearchMetricsAst(self)

    @property
    def ResearchTaskInput(self) -> "ResearchTaskInputAst":
        return ResearchTaskInputAst(self)

    @property
    def SearchParameters(self) -> "SearchParametersAst":
        return SearchParametersAst(self)

    @property
    def SelfReflectionFeedbackOutput(self) -> "SelfReflectionFeedbackOutputAst":
        return SelfReflectionFeedbackOutputAst(self)

    @property
    def SelfReflectionInput(self) -> "SelfReflectionInputAst":
        return SelfReflectionInputAst(self)

    @property
    def SessionSummaryOutputModel(self) -> "SessionSummaryOutputModelAst":
        return SessionSummaryOutputModelAst(self)

    @property
    def SimplifiedQueryOutput(self) -> "SimplifiedQueryOutputAst":
        return SimplifiedQueryOutputAst(self)

    @property
    def SourceAnalysis(self) -> "SourceAnalysisAst":
        return SourceAnalysisAst(self)

    @property
    def SourcePerformanceMetrics(self) -> "SourcePerformanceMetricsAst":
        return SourcePerformanceMetricsAst(self)

    @property
    def StructuredSummaryOutput(self) -> "StructuredSummaryOutputAst":
        return StructuredSummaryOutputAst(self)

    @property
    def StudentHypothesisAnalysis(self) -> "StudentHypothesisAnalysisAst":
        return StudentHypothesisAnalysisAst(self)

    @property
    def SummaryFeedbackOutputModel(self) -> "SummaryFeedbackOutputModelAst":
        return SummaryFeedbackOutputModelAst(self)

    @property
    def SynthesizedResearchOutput(self) -> "SynthesizedResearchOutputAst":
        return SynthesizedResearchOutputAst(self)

    @property
    def TranslationOutput(self) -> "TranslationOutputAst":
        return TranslationOutputAst(self)

    @property
    def VisualDataSummary(self) -> "VisualDataSummaryAst":
        return VisualDataSummaryAst(self)





class AnalyzeDifferentialDiagnosesSNAPPSInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AnalyzeDifferentialDiagnosesSNAPPSInput")
        self._properties: typing.Set[str] = set([ "case_summary",  "student_differential_diagnoses",  "case_context", ])
        self._props = AnalyzeDifferentialDiagnosesSNAPPSInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AnalyzeDifferentialDiagnosesSNAPPSInputProperties":
        return self._props


class AnalyzeDifferentialDiagnosesSNAPPSInputViewer(AnalyzeDifferentialDiagnosesSNAPPSInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class AnalyzeDifferentialDiagnosesSNAPPSInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def case_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("case_summary"))

    @property
    def student_differential_diagnoses(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("student_differential_diagnoses"))

    @property
    def case_context(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("case_context"))

    

class AnswerProbeQuestionsSNAPPSInputModelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AnswerProbeQuestionsSNAPPSInputModel")
        self._properties: typing.Set[str] = set([ "session_context",  "student_questions",  "case_data", ])
        self._props = AnswerProbeQuestionsSNAPPSInputModelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AnswerProbeQuestionsSNAPPSInputModelProperties":
        return self._props


class AnswerProbeQuestionsSNAPPSInputModelViewer(AnswerProbeQuestionsSNAPPSInputModelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class AnswerProbeQuestionsSNAPPSInputModelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def session_context(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("session_context"))

    @property
    def student_questions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("student_questions"))

    @property
    def case_data(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("case_data"))

    

class AnsweredQuestionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AnsweredQuestion")
        self._properties: typing.Set[str] = set([ "question",  "answer",  "rationale", ])
        self._props = AnsweredQuestionProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AnsweredQuestionProperties":
        return self._props


class AnsweredQuestionViewer(AnsweredQuestionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class AnsweredQuestionProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def question(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("question"))

    @property
    def answer(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("answer"))

    @property
    def rationale(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("rationale"))

    

class BAMLProblemRepresentationInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BAMLProblemRepresentationInput")
        self._properties: typing.Set[str] = set([ "full_patient_narrative",  "user_problem_representation",  "user_semantic_qualifiers", ])
        self._props = BAMLProblemRepresentationInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BAMLProblemRepresentationInputProperties":
        return self._props


class BAMLProblemRepresentationInputViewer(BAMLProblemRepresentationInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class BAMLProblemRepresentationInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def full_patient_narrative(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("full_patient_narrative"))

    @property
    def user_problem_representation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("user_problem_representation"))

    @property
    def user_semantic_qualifiers(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("user_semantic_qualifiers"))

    

class BenchmarkComparisonAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BenchmarkComparison")
        self._properties: typing.Set[str] = set([ "industry_percentile",  "performance_grade",  "benchmark_insights",  "improvement_targets", ])
        self._props = BenchmarkComparisonProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BenchmarkComparisonProperties":
        return self._props


class BenchmarkComparisonViewer(BenchmarkComparisonAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class BenchmarkComparisonProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def industry_percentile(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("industry_percentile"))

    @property
    def performance_grade(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("performance_grade"))

    @property
    def benchmark_insights(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("benchmark_insights"))

    @property
    def improvement_targets(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("improvement_targets"))

    

class BiasAnalysisAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BiasAnalysis")
        self._properties: typing.Set[str] = set([ "selection_bias",  "performance_bias",  "reporting_bias",  "confirmation_bias", ])
        self._props = BiasAnalysisProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BiasAnalysisProperties":
        return self._props


class BiasAnalysisViewer(BiasAnalysisAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class BiasAnalysisProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def selection_bias(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("selection_bias"))

    @property
    def performance_bias(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("performance_bias"))

    @property
    def reporting_bias(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reporting_bias"))

    @property
    def confirmation_bias(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("confirmation_bias"))

    

class BiasReflectionPointAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BiasReflectionPoint")
        self._properties: typing.Set[str] = set([ "bias_type",  "reflection_question", ])
        self._props = BiasReflectionPointProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BiasReflectionPointProperties":
        return self._props


class BiasReflectionPointViewer(BiasReflectionPointAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class BiasReflectionPointProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def bias_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("bias_type"))

    @property
    def reflection_question(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reflection_question"))

    

class CaseContextAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CaseContext")
        self._properties: typing.Set[str] = set([ "demographics",  "chief_complaint",  "physical_exam",  "vital_signs",  "full_description",  "expected_differentials",  "learning_objectives",  "expert_analysis", ])
        self._props = CaseContextProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CaseContextProperties":
        return self._props


class CaseContextViewer(CaseContextAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CaseContextProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def demographics(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("demographics"))

    @property
    def chief_complaint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("chief_complaint"))

    @property
    def physical_exam(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("physical_exam"))

    @property
    def vital_signs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("vital_signs"))

    @property
    def full_description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("full_description"))

    @property
    def expected_differentials(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("expected_differentials"))

    @property
    def learning_objectives(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("learning_objectives"))

    @property
    def expert_analysis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("expert_analysis"))

    

class CaseScenarioInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CaseScenarioInput")
        self._properties: typing.Set[str] = set([ "case_vignette",  "initial_findings",  "plausible_hypotheses", ])
        self._props = CaseScenarioInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CaseScenarioInputProperties":
        return self._props


class CaseScenarioInputViewer(CaseScenarioInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CaseScenarioInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def case_vignette(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("case_vignette"))

    @property
    def initial_findings(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("initial_findings"))

    @property
    def plausible_hypotheses(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("plausible_hypotheses"))

    

class CiteSourceAnalysisInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CiteSourceAnalysisInput")
        self._properties: typing.Set[str] = set([ "search_results",  "query",  "include_visualization_data", ])
        self._props = CiteSourceAnalysisInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CiteSourceAnalysisInputProperties":
        return self._props


class CiteSourceAnalysisInputViewer(CiteSourceAnalysisInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CiteSourceAnalysisInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def search_results(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("search_results"))

    @property
    def query(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("query"))

    @property
    def include_visualization_data(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("include_visualization_data"))

    

class CiteSourceAnalysisOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CiteSourceAnalysisOutput")
        self._properties: typing.Set[str] = set([ "deduplication_summary",  "source_performance",  "quality_assessment",  "processing_insights",  "recommendations",  "deduplicated_results",  "processing_metadata", ])
        self._props = CiteSourceAnalysisOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CiteSourceAnalysisOutputProperties":
        return self._props


class CiteSourceAnalysisOutputViewer(CiteSourceAnalysisOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CiteSourceAnalysisOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def deduplication_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("deduplication_summary"))

    @property
    def source_performance(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("source_performance"))

    @property
    def quality_assessment(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("quality_assessment"))

    @property
    def processing_insights(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("processing_insights"))

    @property
    def recommendations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recommendations"))

    @property
    def deduplicated_results(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("deduplicated_results"))

    @property
    def processing_metadata(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("processing_metadata"))

    

class CiteSourceMetricsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CiteSourceMetrics")
        self._properties: typing.Set[str] = set([ "total_sources_consulted",  "original_results_count",  "deduplicated_results_count",  "deduplication_rate",  "overall_quality_score",  "coverage_score",  "diversity_score",  "recency_score",  "impact_score",  "source_balance_score",  "best_performing_source",  "processing_time_ms",  "key_quality_insights", ])
        self._props = CiteSourceMetricsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CiteSourceMetricsProperties":
        return self._props


class CiteSourceMetricsViewer(CiteSourceMetricsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CiteSourceMetricsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def total_sources_consulted(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("total_sources_consulted"))

    @property
    def original_results_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("original_results_count"))

    @property
    def deduplicated_results_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("deduplicated_results_count"))

    @property
    def deduplication_rate(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("deduplication_rate"))

    @property
    def overall_quality_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("overall_quality_score"))

    @property
    def coverage_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("coverage_score"))

    @property
    def diversity_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("diversity_score"))

    @property
    def recency_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recency_score"))

    @property
    def impact_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("impact_score"))

    @property
    def source_balance_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("source_balance_score"))

    @property
    def best_performing_source(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("best_performing_source"))

    @property
    def processing_time_ms(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("processing_time_ms"))

    @property
    def key_quality_insights(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_quality_insights"))

    

class CiteSourceReportInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CiteSourceReportInput")
        self._properties: typing.Set[str] = set([ "query",  "max_results",  "include_detailed_metrics",  "include_recommendations", ])
        self._props = CiteSourceReportInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CiteSourceReportInputProperties":
        return self._props


class CiteSourceReportInputViewer(CiteSourceReportInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CiteSourceReportInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def query(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("query"))

    @property
    def max_results(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("max_results"))

    @property
    def include_detailed_metrics(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("include_detailed_metrics"))

    @property
    def include_recommendations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("include_recommendations"))

    

class CiteSourceReportOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CiteSourceReportOutput")
        self._properties: typing.Set[str] = set([ "executive_summary",  "quality_breakdown",  "source_analysis",  "deduplication_analysis",  "actionable_insights",  "benchmark_comparison",  "visual_data_summary",  "disclaimer", ])
        self._props = CiteSourceReportOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CiteSourceReportOutputProperties":
        return self._props


class CiteSourceReportOutputViewer(CiteSourceReportOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CiteSourceReportOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def executive_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("executive_summary"))

    @property
    def quality_breakdown(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("quality_breakdown"))

    @property
    def source_analysis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("source_analysis"))

    @property
    def deduplication_analysis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("deduplication_analysis"))

    @property
    def actionable_insights(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("actionable_insights"))

    @property
    def benchmark_comparison(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("benchmark_comparison"))

    @property
    def visual_data_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("visual_data_summary"))

    @property
    def disclaimer(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("disclaimer"))

    

class ClinicalDataInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ClinicalDataInput")
        self._properties: typing.Set[str] = set([ "patient_story",  "known_findings",  "patient_demographics", ])
        self._props = ClinicalDataInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ClinicalDataInputProperties":
        return self._props


class ClinicalDataInputViewer(ClinicalDataInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ClinicalDataInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def patient_story(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("patient_story"))

    @property
    def known_findings(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("known_findings"))

    @property
    def patient_demographics(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("patient_demographics"))

    

class ClinicalFindingAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ClinicalFinding")
        self._properties: typing.Set[str] = set([ "finding_name",  "details",  "onset_duration_pattern",  "severity_level", ])
        self._props = ClinicalFindingProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ClinicalFindingProperties":
        return self._props


class ClinicalFindingViewer(ClinicalFindingAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ClinicalFindingProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def finding_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("finding_name"))

    @property
    def details(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("details"))

    @property
    def onset_duration_pattern(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("onset_duration_pattern"))

    @property
    def severity_level(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("severity_level"))

    

class ClinicalScenarioInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ClinicalScenarioInput")
        self._properties: typing.Set[str] = set([ "clinical_scenario",  "additional_context", ])
        self._props = ClinicalScenarioInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ClinicalScenarioInputProperties":
        return self._props


class ClinicalScenarioInputViewer(ClinicalScenarioInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ClinicalScenarioInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def clinical_scenario(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("clinical_scenario"))

    @property
    def additional_context(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("additional_context"))

    

class ClinicalWorkflowQuestionsOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ClinicalWorkflowQuestionsOutput")
        self._properties: typing.Set[str] = set([ "question_categories",  "red_flag_questions",  "overall_rationale", ])
        self._props = ClinicalWorkflowQuestionsOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ClinicalWorkflowQuestionsOutputProperties":
        return self._props


class ClinicalWorkflowQuestionsOutputViewer(ClinicalWorkflowQuestionsOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ClinicalWorkflowQuestionsOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def question_categories(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("question_categories"))

    @property
    def red_flag_questions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("red_flag_questions"))

    @property
    def overall_rationale(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("overall_rationale"))

    

class CognitiveBiasInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CognitiveBiasInput")
        self._properties: typing.Set[str] = set([ "case_summary_by_user",  "user_working_hypothesis",  "user_reasoning_summary", ])
        self._props = CognitiveBiasInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CognitiveBiasInputProperties":
        return self._props


class CognitiveBiasInputViewer(CognitiveBiasInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CognitiveBiasInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def case_summary_by_user(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("case_summary_by_user"))

    @property
    def user_working_hypothesis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("user_working_hypothesis"))

    @property
    def user_reasoning_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("user_reasoning_summary"))

    

class CognitiveBiasReflectionOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CognitiveBiasReflectionOutput")
        self._properties: typing.Set[str] = set([ "potential_biases_to_consider", ])
        self._props = CognitiveBiasReflectionOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CognitiveBiasReflectionOutputProperties":
        return self._props


class CognitiveBiasReflectionOutputViewer(CognitiveBiasReflectionOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CognitiveBiasReflectionOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def potential_biases_to_consider(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("potential_biases_to_consider"))

    

class CompareContrastExerciseInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CompareContrastExerciseInput")
        self._properties: typing.Set[str] = set([ "scenario",  "student_analysis", ])
        self._props = CompareContrastExerciseInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CompareContrastExerciseInputProperties":
        return self._props


class CompareContrastExerciseInputViewer(CompareContrastExerciseInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CompareContrastExerciseInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def scenario(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("scenario"))

    @property
    def student_analysis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("student_analysis"))

    

class CompareContrastFeedbackOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CompareContrastFeedbackOutput")
        self._properties: typing.Set[str] = set([ "overall_feedback",  "detailed_feedback_per_hypothesis",  "suggested_learning_focus", ])
        self._props = CompareContrastFeedbackOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CompareContrastFeedbackOutputProperties":
        return self._props


class CompareContrastFeedbackOutputViewer(CompareContrastFeedbackOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CompareContrastFeedbackOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def overall_feedback(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("overall_feedback"))

    @property
    def detailed_feedback_per_hypothesis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("detailed_feedback_per_hypothesis"))

    @property
    def suggested_learning_focus(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("suggested_learning_focus"))

    

class DdxEvaluationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DdxEvaluation")
        self._properties: typing.Set[str] = set([ "diagnosis",  "plausibility",  "supporting_findings",  "contradicting_findings", ])
        self._props = DdxEvaluationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DdxEvaluationProperties":
        return self._props


class DdxEvaluationViewer(DdxEvaluationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DdxEvaluationProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def diagnosis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("diagnosis"))

    @property
    def plausibility(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("plausibility"))

    @property
    def supporting_findings(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("supporting_findings"))

    @property
    def contradicting_findings(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("contradicting_findings"))

    

class DdxQuestioningInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DdxQuestioningInput")
        self._properties: typing.Set[str] = set([ "chief_complaint",  "initial_findings",  "patient_demographics", ])
        self._props = DdxQuestioningInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DdxQuestioningInputProperties":
        return self._props


class DdxQuestioningInputViewer(DdxQuestioningInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DdxQuestioningInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def chief_complaint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("chief_complaint"))

    @property
    def initial_findings(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("initial_findings"))

    @property
    def patient_demographics(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("patient_demographics"))

    

class DdxQuestioningOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DdxQuestioningOutput")
        self._properties: typing.Set[str] = set([ "prioritized_questions",  "complementary_questions",  "questioning_rationale",  "potential_systems_to_explore", ])
        self._props = DdxQuestioningOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DdxQuestioningOutputProperties":
        return self._props


class DdxQuestioningOutputViewer(DdxQuestioningOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DdxQuestioningOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def prioritized_questions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("prioritized_questions"))

    @property
    def complementary_questions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("complementary_questions"))

    @property
    def questioning_rationale(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("questioning_rationale"))

    @property
    def potential_systems_to_explore(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("potential_systems_to_explore"))

    

class DeduplicationAnalysisAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DeduplicationAnalysis")
        self._properties: typing.Set[str] = set([ "efficiency_metrics",  "duplication_patterns",  "source_overlap_analysis",  "optimization_suggestions", ])
        self._props = DeduplicationAnalysisProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DeduplicationAnalysisProperties":
        return self._props


class DeduplicationAnalysisViewer(DeduplicationAnalysisAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DeduplicationAnalysisProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def efficiency_metrics(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("efficiency_metrics"))

    @property
    def duplication_patterns(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("duplication_patterns"))

    @property
    def source_overlap_analysis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("source_overlap_analysis"))

    @property
    def optimization_suggestions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("optimization_suggestions"))

    

class DeduplicationSummaryAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DeduplicationSummary")
        self._properties: typing.Set[str] = set([ "original_count",  "deduplicated_count",  "removed_duplicates",  "deduplication_rate",  "efficiency_score", ])
        self._props = DeduplicationSummaryProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DeduplicationSummaryProperties":
        return self._props


class DeduplicationSummaryViewer(DeduplicationSummaryAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DeduplicationSummaryProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def original_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("original_count"))

    @property
    def deduplicated_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("deduplicated_count"))

    @property
    def removed_duplicates(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("removed_duplicates"))

    @property
    def deduplication_rate(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("deduplication_rate"))

    @property
    def efficiency_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("efficiency_score"))

    

class DetectedCognitiveBiasAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DetectedCognitiveBias")
        self._properties: typing.Set[str] = set([ "bias_type",  "explanation_as_question",  "mitigation_prompt", ])
        self._props = DetectedCognitiveBiasProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DetectedCognitiveBiasProperties":
        return self._props


class DetectedCognitiveBiasViewer(DetectedCognitiveBiasAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DetectedCognitiveBiasProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def bias_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("bias_type"))

    @property
    def explanation_as_question(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("explanation_as_question"))

    @property
    def mitigation_prompt(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("mitigation_prompt"))

    

class DiagnosticTimeoutInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DiagnosticTimeoutInput")
        self._properties: typing.Set[str] = set([ "case_description",  "current_working_diagnosis",  "time_elapsed_minutes",  "complexity_level", ])
        self._props = DiagnosticTimeoutInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DiagnosticTimeoutInputProperties":
        return self._props


class DiagnosticTimeoutInputViewer(DiagnosticTimeoutInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DiagnosticTimeoutInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def case_description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("case_description"))

    @property
    def current_working_diagnosis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("current_working_diagnosis"))

    @property
    def time_elapsed_minutes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("time_elapsed_minutes"))

    @property
    def complexity_level(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("complexity_level"))

    

class DiagnosticTimeoutOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DiagnosticTimeoutOutput")
        self._properties: typing.Set[str] = set([ "timeout_recommendation",  "alternative_diagnoses_to_consider",  "key_questions_to_ask",  "red_flags_to_check",  "next_steps_suggested",  "cognitive_checks", ])
        self._props = DiagnosticTimeoutOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DiagnosticTimeoutOutputProperties":
        return self._props


class DiagnosticTimeoutOutputViewer(DiagnosticTimeoutOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DiagnosticTimeoutOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def timeout_recommendation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("timeout_recommendation"))

    @property
    def alternative_diagnoses_to_consider(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("alternative_diagnoses_to_consider"))

    @property
    def key_questions_to_ask(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_questions_to_ask"))

    @property
    def red_flags_to_check(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("red_flags_to_check"))

    @property
    def next_steps_suggested(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("next_steps_suggested"))

    @property
    def cognitive_checks(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("cognitive_checks"))

    

class DifferentialAnalysisOutputModelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DifferentialAnalysisOutputModel")
        self._properties: typing.Set[str] = set([ "ddx_evaluation",  "missing_differentials",  "prioritization_feedback",  "socratic_questions",  "next_step_guidance", ])
        self._props = DifferentialAnalysisOutputModelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DifferentialAnalysisOutputModelProperties":
        return self._props


class DifferentialAnalysisOutputModelViewer(DifferentialAnalysisOutputModelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DifferentialAnalysisOutputModelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def ddx_evaluation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("ddx_evaluation"))

    @property
    def missing_differentials(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("missing_differentials"))

    @property
    def prioritization_feedback(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("prioritization_feedback"))

    @property
    def socratic_questions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("socratic_questions"))

    @property
    def next_step_guidance(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("next_step_guidance"))

    

class EvaluateManagementPlanSNAPPSInputModelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EvaluateManagementPlanSNAPPSInputModel")
        self._properties: typing.Set[str] = set([ "session_context",  "student_plan",  "case_data", ])
        self._props = EvaluateManagementPlanSNAPPSInputModelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EvaluateManagementPlanSNAPPSInputModelProperties":
        return self._props


class EvaluateManagementPlanSNAPPSInputModelViewer(EvaluateManagementPlanSNAPPSInputModelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class EvaluateManagementPlanSNAPPSInputModelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def session_context(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("session_context"))

    @property
    def student_plan(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("student_plan"))

    @property
    def case_data(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("case_data"))

    

class EvaluateSummarySNAPPSInputModelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EvaluateSummarySNAPPSInputModel")
        self._properties: typing.Set[str] = set([ "student_summary",  "case_description", ])
        self._props = EvaluateSummarySNAPPSInputModelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EvaluateSummarySNAPPSInputModelProperties":
        return self._props


class EvaluateSummarySNAPPSInputModelViewer(EvaluateSummarySNAPPSInputModelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class EvaluateSummarySNAPPSInputModelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def student_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("student_summary"))

    @property
    def case_description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("case_description"))

    

class EvidenceAnalysisDataAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EvidenceAnalysisData")
        self._properties: typing.Set[str] = set([ "study_objective",  "study_design",  "population",  "interventions",  "primary_outcomes",  "key_results",  "authors_conclusions",  "authors_acknowledged_limitations", ])
        self._props = EvidenceAnalysisDataProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EvidenceAnalysisDataProperties":
        return self._props


class EvidenceAnalysisDataViewer(EvidenceAnalysisDataAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class EvidenceAnalysisDataProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def study_objective(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("study_objective"))

    @property
    def study_design(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("study_design"))

    @property
    def population(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("population"))

    @property
    def interventions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("interventions"))

    @property
    def primary_outcomes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("primary_outcomes"))

    @property
    def key_results(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_results"))

    @property
    def authors_conclusions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("authors_conclusions"))

    @property
    def authors_acknowledged_limitations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("authors_acknowledged_limitations"))

    

class EvidenceAppraisalOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EvidenceAppraisalOutput")
        self._properties: typing.Set[str] = set([ "overall_quality",  "quality_reasoning",  "recommendation_strength",  "strength_reasoning",  "quality_factors",  "bias_analysis",  "practice_recommendations", ])
        self._props = EvidenceAppraisalOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EvidenceAppraisalOutputProperties":
        return self._props


class EvidenceAppraisalOutputViewer(EvidenceAppraisalOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class EvidenceAppraisalOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def overall_quality(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("overall_quality"))

    @property
    def quality_reasoning(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("quality_reasoning"))

    @property
    def recommendation_strength(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recommendation_strength"))

    @property
    def strength_reasoning(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("strength_reasoning"))

    @property
    def quality_factors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("quality_factors"))

    @property
    def bias_analysis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("bias_analysis"))

    @property
    def practice_recommendations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("practice_recommendations"))

    

class EvidenceThemeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EvidenceTheme")
        self._properties: typing.Set[str] = set([ "theme_name",  "key_findings",  "strength_of_evidence",  "supporting_studies_count", ])
        self._props = EvidenceThemeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EvidenceThemeProperties":
        return self._props


class EvidenceThemeViewer(EvidenceThemeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class EvidenceThemeProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def theme_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("theme_name"))

    @property
    def key_findings(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_findings"))

    @property
    def strength_of_evidence(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("strength_of_evidence"))

    @property
    def supporting_studies_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("supporting_studies_count"))

    

class ExecutiveSummaryAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ExecutiveSummary")
        self._properties: typing.Set[str] = set([ "total_sources_consulted",  "deduplication_efficiency_rate",  "overall_quality_grade",  "best_performing_source",  "key_strengths",  "key_improvement_areas", ])
        self._props = ExecutiveSummaryProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ExecutiveSummaryProperties":
        return self._props


class ExecutiveSummaryViewer(ExecutiveSummaryAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ExecutiveSummaryProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def total_sources_consulted(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("total_sources_consulted"))

    @property
    def deduplication_efficiency_rate(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("deduplication_efficiency_rate"))

    @property
    def overall_quality_grade(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("overall_quality_grade"))

    @property
    def best_performing_source(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("best_performing_source"))

    @property
    def key_strengths(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_strengths"))

    @property
    def key_improvement_areas(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_improvement_areas"))

    

class ExpandDifferentialDiagnosisInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ExpandDifferentialDiagnosisInput")
        self._properties: typing.Set[str] = set([ "presenting_complaint",  "location_if_pain",  "student_initial_ddx_list", ])
        self._props = ExpandDifferentialDiagnosisInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ExpandDifferentialDiagnosisInputProperties":
        return self._props


class ExpandDifferentialDiagnosisInputViewer(ExpandDifferentialDiagnosisInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ExpandDifferentialDiagnosisInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def presenting_complaint(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("presenting_complaint"))

    @property
    def location_if_pain(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("location_if_pain"))

    @property
    def student_initial_ddx_list(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("student_initial_ddx_list"))

    

class ExpandedDdxOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ExpandedDdxOutput")
        self._properties: typing.Set[str] = set([ "applied_approach_description",  "suggested_additional_diagnoses_with_rationale", ])
        self._props = ExpandedDdxOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ExpandedDdxOutputProperties":
        return self._props


class ExpandedDdxOutputViewer(ExpandedDdxOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ExpandedDdxOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def applied_approach_description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("applied_approach_description"))

    @property
    def suggested_additional_diagnoses_with_rationale(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("suggested_additional_diagnoses_with_rationale"))

    

class FacilitateDDxAnalysisOutputModelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FacilitateDDxAnalysisOutputModel")
        self._properties: typing.Set[str] = set([ "response", ])
        self._props = FacilitateDDxAnalysisOutputModelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FacilitateDDxAnalysisOutputModelProperties":
        return self._props


class FacilitateDDxAnalysisOutputModelViewer(FacilitateDDxAnalysisOutputModelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class FacilitateDDxAnalysisOutputModelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def response(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("response"))

    

class FacilitateDDxAnalysisSNAPPSInputModelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FacilitateDDxAnalysisSNAPPSInputModel")
        self._properties: typing.Set[str] = set([ "case_summary",  "differential_diagnoses",  "student_analysis",  "case_context", ])
        self._props = FacilitateDDxAnalysisSNAPPSInputModelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FacilitateDDxAnalysisSNAPPSInputModelProperties":
        return self._props


class FacilitateDDxAnalysisSNAPPSInputModelViewer(FacilitateDDxAnalysisSNAPPSInputModelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class FacilitateDDxAnalysisSNAPPSInputModelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def case_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("case_summary"))

    @property
    def differential_diagnoses(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("differential_diagnoses"))

    @property
    def student_analysis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("student_analysis"))

    @property
    def case_context(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("case_context"))

    

class FormulatedSearchStrategyOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FormulatedSearchStrategyOutput")
        self._properties: typing.Set[str] = set([ "refined_query_for_llm_synthesis",  "search_parameters_list",  "search_rationale",  "expected_evidence_types", ])
        self._props = FormulatedSearchStrategyOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FormulatedSearchStrategyOutputProperties":
        return self._props


class FormulatedSearchStrategyOutputViewer(FormulatedSearchStrategyOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class FormulatedSearchStrategyOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def refined_query_for_llm_synthesis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("refined_query_for_llm_synthesis"))

    @property
    def search_parameters_list(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("search_parameters_list"))

    @property
    def search_rationale(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("search_rationale"))

    @property
    def expected_evidence_types(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("expected_evidence_types"))

    

class HypothesisComparisonFeedbackAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("HypothesisComparisonFeedback")
        self._properties: typing.Set[str] = set([ "hypothesis_name",  "feedback_on_supporting_findings",  "feedback_on_refuting_findings",  "feedback_on_discriminators",  "expert_comparison_points", ])
        self._props = HypothesisComparisonFeedbackProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "HypothesisComparisonFeedbackProperties":
        return self._props


class HypothesisComparisonFeedbackViewer(HypothesisComparisonFeedbackAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class HypothesisComparisonFeedbackProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def hypothesis_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("hypothesis_name"))

    @property
    def feedback_on_supporting_findings(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("feedback_on_supporting_findings"))

    @property
    def feedback_on_refuting_findings(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("feedback_on_refuting_findings"))

    @property
    def feedback_on_discriminators(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("feedback_on_discriminators"))

    @property
    def expert_comparison_points(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("expert_comparison_points"))

    

class IllnessScriptInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IllnessScriptInput")
        self._properties: typing.Set[str] = set([ "disease_name", ])
        self._props = IllnessScriptInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IllnessScriptInputProperties":
        return self._props


class IllnessScriptInputViewer(IllnessScriptInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class IllnessScriptInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def disease_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("disease_name"))

    

class IllnessScriptOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IllnessScriptOutput")
        self._properties: typing.Set[str] = set([ "disease_name",  "predisposing_conditions",  "pathophysiology_summary",  "key_symptoms_and_signs",  "relevant_diagnostics", ])
        self._props = IllnessScriptOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IllnessScriptOutputProperties":
        return self._props


class IllnessScriptOutputViewer(IllnessScriptOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class IllnessScriptOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def disease_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("disease_name"))

    @property
    def predisposing_conditions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("predisposing_conditions"))

    @property
    def pathophysiology_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("pathophysiology_summary"))

    @property
    def key_symptoms_and_signs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_symptoms_and_signs"))

    @property
    def relevant_diagnostics(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("relevant_diagnostics"))

    

class InterventionInfoAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("InterventionInfo")
        self._properties: typing.Set[str] = set([ "intervention_details",  "comparator_details", ])
        self._props = InterventionInfoProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "InterventionInfoProperties":
        return self._props


class InterventionInfoViewer(InterventionInfoAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class InterventionInfoProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def intervention_details(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("intervention_details"))

    @property
    def comparator_details(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("comparator_details"))

    

class KeyResultAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("KeyResult")
        self._properties: typing.Set[str] = set([ "finding_description",  "reported_values", ])
        self._props = KeyResultProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "KeyResultProperties":
        return self._props


class KeyResultViewer(KeyResultAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class KeyResultProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def finding_description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("finding_description"))

    @property
    def reported_values(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reported_values"))

    

class LabAnalysisInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("LabAnalysisInput")
        self._properties: typing.Set[str] = set([ "lab_results",  "user_role",  "patient_context",  "specific_user_query", ])
        self._props = LabAnalysisInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "LabAnalysisInputProperties":
        return self._props


class LabAnalysisInputViewer(LabAnalysisInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class LabAnalysisInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def lab_results(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("lab_results"))

    @property
    def user_role(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("user_role"))

    @property
    def patient_context(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("patient_context"))

    @property
    def specific_user_query(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("specific_user_query"))

    

class LabInsightsOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("LabInsightsOutput")
        self._properties: typing.Set[str] = set([ "patient_friendly_summary",  "potential_health_implications_patient",  "lifestyle_tips_patient",  "important_results_to_discuss_with_doctor",  "professional_detailed_reasoning_cot",  "key_abnormalities_professional",  "key_normal_results_with_context",  "potential_patterns_and_correlations",  "differential_considerations_professional",  "suggested_next_steps_professional", ])
        self._props = LabInsightsOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "LabInsightsOutputProperties":
        return self._props


class LabInsightsOutputViewer(LabInsightsOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class LabInsightsOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def patient_friendly_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("patient_friendly_summary"))

    @property
    def potential_health_implications_patient(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("potential_health_implications_patient"))

    @property
    def lifestyle_tips_patient(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("lifestyle_tips_patient"))

    @property
    def important_results_to_discuss_with_doctor(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("important_results_to_discuss_with_doctor"))

    @property
    def professional_detailed_reasoning_cot(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("professional_detailed_reasoning_cot"))

    @property
    def key_abnormalities_professional(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_abnormalities_professional"))

    @property
    def key_normal_results_with_context(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_normal_results_with_context"))

    @property
    def potential_patterns_and_correlations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("potential_patterns_and_correlations"))

    @property
    def differential_considerations_professional(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("differential_considerations_professional"))

    @property
    def suggested_next_steps_professional(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("suggested_next_steps_professional"))

    

class LabTestResultAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("LabTestResult")
        self._properties: typing.Set[str] = set([ "test_name",  "value",  "unit",  "reference_range_low",  "reference_range_high",  "interpretation_flag",  "notes", ])
        self._props = LabTestResultProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "LabTestResultProperties":
        return self._props


class LabTestResultViewer(LabTestResultAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class LabTestResultProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def test_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("test_name"))

    @property
    def value(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("value"))

    @property
    def unit(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("unit"))

    @property
    def reference_range_low(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reference_range_low"))

    @property
    def reference_range_high(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reference_range_high"))

    @property
    def interpretation_flag(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("interpretation_flag"))

    @property
    def notes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("notes"))

    

class PDFAnalysisInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PDFAnalysisInput")
        self._properties: typing.Set[str] = set([ "pdf_content",  "analysis_focus",  "clinical_question", ])
        self._props = PDFAnalysisInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PDFAnalysisInputProperties":
        return self._props


class PDFAnalysisInputViewer(PDFAnalysisInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PDFAnalysisInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def pdf_content(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("pdf_content"))

    @property
    def analysis_focus(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("analysis_focus"))

    @property
    def clinical_question(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("clinical_question"))

    

class PDFAnalysisOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PDFAnalysisOutput")
        self._properties: typing.Set[str] = set([ "document_type",  "key_findings",  "methodology_summary",  "clinical_relevance",  "evidence_quality",  "recommendations",  "limitations",  "structured_summary", ])
        self._props = PDFAnalysisOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PDFAnalysisOutputProperties":
        return self._props


class PDFAnalysisOutputViewer(PDFAnalysisOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PDFAnalysisOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def document_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("document_type"))

    @property
    def key_findings(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_findings"))

    @property
    def methodology_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("methodology_summary"))

    @property
    def clinical_relevance(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("clinical_relevance"))

    @property
    def evidence_quality(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("evidence_quality"))

    @property
    def recommendations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recommendations"))

    @property
    def limitations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("limitations"))

    @property
    def structured_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("structured_summary"))

    

class PICOFormulationOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PICOFormulationOutput")
        self._properties: typing.Set[str] = set([ "structured_pico_question",  "explanation",  "pico_derivation_reasoning",  "search_terms_suggestions",  "boolean_search_strategies",  "alternative_pico_formulations",  "recommended_study_types", ])
        self._props = PICOFormulationOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PICOFormulationOutputProperties":
        return self._props


class PICOFormulationOutputViewer(PICOFormulationOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PICOFormulationOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def structured_pico_question(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("structured_pico_question"))

    @property
    def explanation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("explanation"))

    @property
    def pico_derivation_reasoning(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("pico_derivation_reasoning"))

    @property
    def search_terms_suggestions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("search_terms_suggestions"))

    @property
    def boolean_search_strategies(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("boolean_search_strategies"))

    @property
    def alternative_pico_formulations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("alternative_pico_formulations"))

    @property
    def recommended_study_types(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recommended_study_types"))

    

class PICOQuestionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PICOQuestion")
        self._properties: typing.Set[str] = set([ "patient_population",  "intervention",  "comparison",  "outcome",  "time_frame",  "study_type", ])
        self._props = PICOQuestionProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PICOQuestionProperties":
        return self._props


class PICOQuestionViewer(PICOQuestionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PICOQuestionProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def patient_population(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("patient_population"))

    @property
    def intervention(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("intervention"))

    @property
    def comparison(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("comparison"))

    @property
    def outcome(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("outcome"))

    @property
    def time_frame(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("time_frame"))

    @property
    def study_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("study_type"))

    

class PatientFollowUpChecklistOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PatientFollowUpChecklistOutput")
        self._properties: typing.Set[str] = set([ "checklist_items",  "when_to_contact_doctor_urgently",  "general_advice", ])
        self._props = PatientFollowUpChecklistOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PatientFollowUpChecklistOutputProperties":
        return self._props


class PatientFollowUpChecklistOutputViewer(PatientFollowUpChecklistOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PatientFollowUpChecklistOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def checklist_items(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("checklist_items"))

    @property
    def when_to_contact_doctor_urgently(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("when_to_contact_doctor_urgently"))

    @property
    def general_advice(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("general_advice"))

    

class PatientFollowUpInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PatientFollowUpInput")
        self._properties: typing.Set[str] = set([ "consultation_summary_or_concept_explained",  "doctor_recommendations_summary", ])
        self._props = PatientFollowUpInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PatientFollowUpInputProperties":
        return self._props


class PatientFollowUpInputViewer(PatientFollowUpInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PatientFollowUpInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def consultation_summary_or_concept_explained(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("consultation_summary_or_concept_explained"))

    @property
    def doctor_recommendations_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("doctor_recommendations_summary"))

    

class PlanEvaluationOutputModelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PlanEvaluationOutputModel")
        self._properties: typing.Set[str] = set([ "plan_strengths",  "plan_gaps",  "investigation_priorities",  "management_considerations",  "safety_concerns",  "cost_effectiveness_notes",  "guidelines_alignment",  "next_step_guidance", ])
        self._props = PlanEvaluationOutputModelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlanEvaluationOutputModelProperties":
        return self._props


class PlanEvaluationOutputModelViewer(PlanEvaluationOutputModelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlanEvaluationOutputModelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def plan_strengths(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("plan_strengths"))

    @property
    def plan_gaps(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("plan_gaps"))

    @property
    def investigation_priorities(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("investigation_priorities"))

    @property
    def management_considerations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("management_considerations"))

    @property
    def safety_concerns(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("safety_concerns"))

    @property
    def cost_effectiveness_notes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("cost_effectiveness_notes"))

    @property
    def guidelines_alignment(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("guidelines_alignment"))

    @property
    def next_step_guidance(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("next_step_guidance"))

    

class PopulationInfoAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PopulationInfo")
        self._properties: typing.Set[str] = set([ "sample_size",  "key_demographics",  "inclusion_criteria",  "exclusion_criteria", ])
        self._props = PopulationInfoProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PopulationInfoProperties":
        return self._props


class PopulationInfoViewer(PopulationInfoAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PopulationInfoProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def sample_size(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("sample_size"))

    @property
    def key_demographics(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_demographics"))

    @property
    def inclusion_criteria(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("inclusion_criteria"))

    @property
    def exclusion_criteria(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("exclusion_criteria"))

    

class ProbeResponseOutputModelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ProbeResponseOutputModel")
        self._properties: typing.Set[str] = set([ "answers_to_questions",  "additional_considerations",  "counter_questions",  "knowledge_gaps_identified",  "learning_resources", ])
        self._props = ProbeResponseOutputModelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ProbeResponseOutputModelProperties":
        return self._props


class ProbeResponseOutputModelViewer(ProbeResponseOutputModelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ProbeResponseOutputModelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def answers_to_questions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("answers_to_questions"))

    @property
    def additional_considerations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("additional_considerations"))

    @property
    def counter_questions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("counter_questions"))

    @property
    def knowledge_gaps_identified(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("knowledge_gaps_identified"))

    @property
    def learning_resources(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("learning_resources"))

    

class ProblemRepresentationFeedbackOutputModelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ProblemRepresentationFeedbackOutputModel")
        self._properties: typing.Set[str] = set([ "feedback_strengths",  "feedback_improvements",  "missing_elements",  "overall_assessment",  "next_step_guidance",  "socratic_questions", ])
        self._props = ProblemRepresentationFeedbackOutputModelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ProblemRepresentationFeedbackOutputModelProperties":
        return self._props


class ProblemRepresentationFeedbackOutputModelViewer(ProblemRepresentationFeedbackOutputModelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ProblemRepresentationFeedbackOutputModelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def feedback_strengths(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("feedback_strengths"))

    @property
    def feedback_improvements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("feedback_improvements"))

    @property
    def missing_elements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("missing_elements"))

    @property
    def overall_assessment(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("overall_assessment"))

    @property
    def next_step_guidance(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("next_step_guidance"))

    @property
    def socratic_questions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("socratic_questions"))

    

class ProcessingMetadataAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ProcessingMetadata")
        self._properties: typing.Set[str] = set([ "total_processing_time_ms",  "sources_analyzed",  "timestamp",  "version", ])
        self._props = ProcessingMetadataProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ProcessingMetadataProperties":
        return self._props


class ProcessingMetadataViewer(ProcessingMetadataAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ProcessingMetadataProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def total_processing_time_ms(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("total_processing_time_ms"))

    @property
    def sources_analyzed(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("sources_analyzed"))

    @property
    def timestamp(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("timestamp"))

    @property
    def version(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("version"))

    

class ProvideSessionSummarySNAPPSInputModelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ProvideSessionSummarySNAPPSInputModel")
        self._properties: typing.Set[str] = set([ "session_history",  "case_context",  "student_selected_topic", ])
        self._props = ProvideSessionSummarySNAPPSInputModelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ProvideSessionSummarySNAPPSInputModelProperties":
        return self._props


class ProvideSessionSummarySNAPPSInputModelViewer(ProvideSessionSummarySNAPPSInputModelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ProvideSessionSummarySNAPPSInputModelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def session_history(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("session_history"))

    @property
    def case_context(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("case_context"))

    @property
    def student_selected_topic(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("student_selected_topic"))

    

class QualityFactorAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("QualityFactor")
        self._properties: typing.Set[str] = set([ "factor_name",  "assessment",  "justification", ])
        self._props = QualityFactorProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "QualityFactorProperties":
        return self._props


class QualityFactorViewer(QualityFactorAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class QualityFactorProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def factor_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("factor_name"))

    @property
    def assessment(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("assessment"))

    @property
    def justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("justification"))

    

class QualityScoresAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("QualityScores")
        self._properties: typing.Set[str] = set([ "overall_score",  "coverage_score",  "diversity_score",  "recency_score",  "impact_score",  "source_balance_score", ])
        self._props = QualityScoresProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "QualityScoresProperties":
        return self._props


class QualityScoresViewer(QualityScoresAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class QualityScoresProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def overall_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("overall_score"))

    @property
    def coverage_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("coverage_score"))

    @property
    def diversity_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("diversity_score"))

    @property
    def recency_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recency_score"))

    @property
    def impact_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("impact_score"))

    @property
    def source_balance_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("source_balance_score"))

    

class QuestionCategoryAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("QuestionCategory")
        self._properties: typing.Set[str] = set([ "category_name",  "questions",  "category_rationale", ])
        self._props = QuestionCategoryProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "QuestionCategoryProperties":
        return self._props


class QuestionCategoryViewer(QuestionCategoryAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class QuestionCategoryProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def category_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("category_name"))

    @property
    def questions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("questions"))

    @property
    def category_rationale(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("category_rationale"))

    

class RawSearchResultItemAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("RawSearchResultItem")
        self._properties: typing.Set[str] = set([ "source",  "title",  "url",  "snippet_or_abstract",  "publication_date",  "authors",  "journal",  "pmid",  "doi",  "study_type",  "citation_count",  "relevance_score",  "composite_impact_score",  "academic_source_name", ])
        self._props = RawSearchResultItemProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "RawSearchResultItemProperties":
        return self._props


class RawSearchResultItemViewer(RawSearchResultItemAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class RawSearchResultItemProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def source(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("source"))

    @property
    def title(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("title"))

    @property
    def url(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("url"))

    @property
    def snippet_or_abstract(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("snippet_or_abstract"))

    @property
    def publication_date(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("publication_date"))

    @property
    def authors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("authors"))

    @property
    def journal(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("journal"))

    @property
    def pmid(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("pmid"))

    @property
    def doi(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("doi"))

    @property
    def study_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("study_type"))

    @property
    def citation_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("citation_count"))

    @property
    def relevance_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("relevance_score"))

    @property
    def composite_impact_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("composite_impact_score"))

    @property
    def academic_source_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("academic_source_name"))

    

class ResearchMetricsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResearchMetrics")
        self._properties: typing.Set[str] = set([ "total_articles_analyzed",  "sources_consulted",  "search_duration_seconds",  "quality_filters_applied",  "date_range_searched",  "language_filters_applied",  "search_strategy_summary",  "unique_journals_found",  "high_impact_studies_count",  "recent_studies_count",  "systematic_reviews_count",  "rct_count",  "cite_source_metrics", ])
        self._props = ResearchMetricsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResearchMetricsProperties":
        return self._props


class ResearchMetricsViewer(ResearchMetricsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ResearchMetricsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def total_articles_analyzed(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("total_articles_analyzed"))

    @property
    def sources_consulted(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("sources_consulted"))

    @property
    def search_duration_seconds(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("search_duration_seconds"))

    @property
    def quality_filters_applied(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("quality_filters_applied"))

    @property
    def date_range_searched(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("date_range_searched"))

    @property
    def language_filters_applied(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("language_filters_applied"))

    @property
    def search_strategy_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("search_strategy_summary"))

    @property
    def unique_journals_found(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("unique_journals_found"))

    @property
    def high_impact_studies_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("high_impact_studies_count"))

    @property
    def recent_studies_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recent_studies_count"))

    @property
    def systematic_reviews_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("systematic_reviews_count"))

    @property
    def rct_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("rct_count"))

    @property
    def cite_source_metrics(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("cite_source_metrics"))

    

class ResearchTaskInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResearchTaskInput")
        self._properties: typing.Set[str] = set([ "user_original_query",  "pico_question",  "research_focus",  "target_audience",  "research_mode", ])
        self._props = ResearchTaskInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResearchTaskInputProperties":
        return self._props


class ResearchTaskInputViewer(ResearchTaskInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ResearchTaskInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def user_original_query(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("user_original_query"))

    @property
    def pico_question(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("pico_question"))

    @property
    def research_focus(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("research_focus"))

    @property
    def target_audience(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("target_audience"))

    @property
    def research_mode(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("research_mode"))

    

class SearchParametersAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SearchParameters")
        self._properties: typing.Set[str] = set([ "source",  "query_string",  "max_results",  "study_type_filter",  "date_range_years",  "language_filter",  "rationale", ])
        self._props = SearchParametersProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SearchParametersProperties":
        return self._props


class SearchParametersViewer(SearchParametersAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SearchParametersProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def source(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("source"))

    @property
    def query_string(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("query_string"))

    @property
    def max_results(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("max_results"))

    @property
    def study_type_filter(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("study_type_filter"))

    @property
    def date_range_years(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("date_range_years"))

    @property
    def language_filter(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("language_filter"))

    @property
    def rationale(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("rationale"))

    

class SelfReflectionFeedbackOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SelfReflectionFeedbackOutput")
        self._properties: typing.Set[str] = set([ "identified_reasoning_pattern",  "bias_reflection_points",  "devils_advocate_challenge",  "suggested_next_reflective_action", ])
        self._props = SelfReflectionFeedbackOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SelfReflectionFeedbackOutputProperties":
        return self._props


class SelfReflectionFeedbackOutputViewer(SelfReflectionFeedbackOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SelfReflectionFeedbackOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def identified_reasoning_pattern(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("identified_reasoning_pattern"))

    @property
    def bias_reflection_points(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("bias_reflection_points"))

    @property
    def devils_advocate_challenge(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("devils_advocate_challenge"))

    @property
    def suggested_next_reflective_action(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("suggested_next_reflective_action"))

    

class SelfReflectionInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SelfReflectionInput")
        self._properties: typing.Set[str] = set([ "clinical_scenario",  "user_hypothesis",  "user_reasoning_summary", ])
        self._props = SelfReflectionInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SelfReflectionInputProperties":
        return self._props


class SelfReflectionInputViewer(SelfReflectionInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SelfReflectionInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def clinical_scenario(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("clinical_scenario"))

    @property
    def user_hypothesis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("user_hypothesis"))

    @property
    def user_reasoning_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("user_reasoning_summary"))

    

class SessionSummaryOutputModelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionSummaryOutputModel")
        self._properties: typing.Set[str] = set([ "overall_performance",  "key_strengths",  "areas_for_development",  "learning_objectives_met",  "recommended_study_topics",  "metacognitive_insights",  "next_cases_suggestions", ])
        self._props = SessionSummaryOutputModelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionSummaryOutputModelProperties":
        return self._props


class SessionSummaryOutputModelViewer(SessionSummaryOutputModelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SessionSummaryOutputModelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def overall_performance(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("overall_performance"))

    @property
    def key_strengths(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_strengths"))

    @property
    def areas_for_development(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("areas_for_development"))

    @property
    def learning_objectives_met(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("learning_objectives_met"))

    @property
    def recommended_study_topics(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recommended_study_topics"))

    @property
    def metacognitive_insights(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("metacognitive_insights"))

    @property
    def next_cases_suggestions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("next_cases_suggestions"))

    

class SimplifiedQueryOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SimplifiedQueryOutput")
        self._properties: typing.Set[str] = set([ "simplified_query", ])
        self._props = SimplifiedQueryOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SimplifiedQueryOutputProperties":
        return self._props


class SimplifiedQueryOutputViewer(SimplifiedQueryOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SimplifiedQueryOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def simplified_query(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("simplified_query"))

    

class SourceAnalysisAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SourceAnalysis")
        self._properties: typing.Set[str] = set([ "source_rankings",  "coverage_analysis",  "diversity_assessment",  "performance_insights", ])
        self._props = SourceAnalysisProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SourceAnalysisProperties":
        return self._props


class SourceAnalysisViewer(SourceAnalysisAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SourceAnalysisProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def source_rankings(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("source_rankings"))

    @property
    def coverage_analysis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("coverage_analysis"))

    @property
    def diversity_assessment(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("diversity_assessment"))

    @property
    def performance_insights(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("performance_insights"))

    

class SourcePerformanceMetricsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SourcePerformanceMetrics")
        self._properties: typing.Set[str] = set([ "source_name",  "total_results",  "unique_contributions",  "quality_score",  "response_time_ms",  "recent_publications_count",  "high_impact_count", ])
        self._props = SourcePerformanceMetricsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SourcePerformanceMetricsProperties":
        return self._props


class SourcePerformanceMetricsViewer(SourcePerformanceMetricsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SourcePerformanceMetricsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def source_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("source_name"))

    @property
    def total_results(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("total_results"))

    @property
    def unique_contributions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("unique_contributions"))

    @property
    def quality_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("quality_score"))

    @property
    def response_time_ms(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("response_time_ms"))

    @property
    def recent_publications_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recent_publications_count"))

    @property
    def high_impact_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("high_impact_count"))

    

class StructuredSummaryOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StructuredSummaryOutput")
        self._properties: typing.Set[str] = set([ "one_sentence_summary",  "semantic_qualifiers_identified",  "key_patient_details_abstracted",  "suggested_areas_for_further_data_gathering", ])
        self._props = StructuredSummaryOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StructuredSummaryOutputProperties":
        return self._props


class StructuredSummaryOutputViewer(StructuredSummaryOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class StructuredSummaryOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def one_sentence_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("one_sentence_summary"))

    @property
    def semantic_qualifiers_identified(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("semantic_qualifiers_identified"))

    @property
    def key_patient_details_abstracted(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_patient_details_abstracted"))

    @property
    def suggested_areas_for_further_data_gathering(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("suggested_areas_for_further_data_gathering"))

    

class StudentHypothesisAnalysisAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StudentHypothesisAnalysis")
        self._properties: typing.Set[str] = set([ "hypothesis_name",  "supporting_findings",  "refuting_findings",  "key_discriminators_against_others", ])
        self._props = StudentHypothesisAnalysisProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StudentHypothesisAnalysisProperties":
        return self._props


class StudentHypothesisAnalysisViewer(StudentHypothesisAnalysisAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class StudentHypothesisAnalysisProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def hypothesis_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("hypothesis_name"))

    @property
    def supporting_findings(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("supporting_findings"))

    @property
    def refuting_findings(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("refuting_findings"))

    @property
    def key_discriminators_against_others(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_discriminators_against_others"))

    

class SummaryFeedbackOutputModelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SummaryFeedbackOutputModel")
        self._properties: typing.Set[str] = set([ "feedback_strengths",  "feedback_improvements",  "missing_elements",  "overall_assessment",  "next_step_guidance",  "socratic_questions", ])
        self._props = SummaryFeedbackOutputModelProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SummaryFeedbackOutputModelProperties":
        return self._props


class SummaryFeedbackOutputModelViewer(SummaryFeedbackOutputModelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SummaryFeedbackOutputModelProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def feedback_strengths(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("feedback_strengths"))

    @property
    def feedback_improvements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("feedback_improvements"))

    @property
    def missing_elements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("missing_elements"))

    @property
    def overall_assessment(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("overall_assessment"))

    @property
    def next_step_guidance(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("next_step_guidance"))

    @property
    def socratic_questions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("socratic_questions"))

    

class SynthesizedResearchOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SynthesizedResearchOutput")
        self._properties: typing.Set[str] = set([ "original_query",  "executive_summary",  "professional_detailed_reasoning_cot",  "clinical_implications",  "key_findings_by_theme",  "research_gaps_identified",  "evidence_quality_assessment",  "relevant_references",  "research_metrics",  "search_duration_seconds", ])
        self._props = SynthesizedResearchOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SynthesizedResearchOutputProperties":
        return self._props


class SynthesizedResearchOutputViewer(SynthesizedResearchOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SynthesizedResearchOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def original_query(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("original_query"))

    @property
    def executive_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("executive_summary"))

    @property
    def professional_detailed_reasoning_cot(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("professional_detailed_reasoning_cot"))

    @property
    def clinical_implications(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("clinical_implications"))

    @property
    def key_findings_by_theme(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_findings_by_theme"))

    @property
    def research_gaps_identified(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("research_gaps_identified"))

    @property
    def evidence_quality_assessment(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("evidence_quality_assessment"))

    @property
    def relevant_references(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("relevant_references"))

    @property
    def research_metrics(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("research_metrics"))

    @property
    def search_duration_seconds(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("search_duration_seconds"))

    

class TranslationOutputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TranslationOutput")
        self._properties: typing.Set[str] = set([ "translated_text", ])
        self._props = TranslationOutputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TranslationOutputProperties":
        return self._props


class TranslationOutputViewer(TranslationOutputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class TranslationOutputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def translated_text(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("translated_text"))

    

class VisualDataSummaryAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VisualDataSummary")
        self._properties: typing.Set[str] = set([ "chart_data_available",  "supported_visualizations",  "data_summary", ])
        self._props = VisualDataSummaryProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VisualDataSummaryProperties":
        return self._props


class VisualDataSummaryViewer(VisualDataSummaryAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class VisualDataSummaryProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def chart_data_available(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("chart_data_available"))

    @property
    def supported_visualizations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("supported_visualizations"))

    @property
    def data_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("data_summary"))

    



class AssessmentValueAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("AssessmentValue")
        self._values: typing.Set[str] = set([ "POSITIVO",  "NEUTRO",  "NEGATIVO", ])
        self._vals = AssessmentValueValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "AssessmentValueValues":
        return self._vals


class AssessmentValueViewer(AssessmentValueAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class AssessmentValueValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def POSITIVO(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("POSITIVO"))
    

    @property
    def NEUTRO(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("NEUTRO"))
    

    @property
    def NEGATIVO(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("NEGATIVO"))
    

    

class GradeLevelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("GradeLevel")
        self._values: typing.Set[str] = set([ "ALTA",  "MODERADA",  "BAIXA",  "MUITO_BAIXA", ])
        self._vals = GradeLevelValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "GradeLevelValues":
        return self._vals


class GradeLevelViewer(GradeLevelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class GradeLevelValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def ALTA(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("ALTA"))
    

    @property
    def MODERADA(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("MODERADA"))
    

    @property
    def BAIXA(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("BAIXA"))
    

    @property
    def MUITO_BAIXA(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("MUITO_BAIXA"))
    

    

class PossibleCognitiveBiasAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("PossibleCognitiveBias")
        self._values: typing.Set[str] = set([ "ANCHORING",  "CONFIRMATION_BIAS",  "PREMATURE_CLOSURE",  "AVAILABILITY_HEURISTIC",  "REPRESENTATIVENESS_HEURISTIC", ])
        self._vals = PossibleCognitiveBiasValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "PossibleCognitiveBiasValues":
        return self._vals


class PossibleCognitiveBiasViewer(PossibleCognitiveBiasAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class PossibleCognitiveBiasValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def ANCHORING(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("ANCHORING"))
    

    @property
    def CONFIRMATION_BIAS(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("CONFIRMATION_BIAS"))
    

    @property
    def PREMATURE_CLOSURE(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("PREMATURE_CLOSURE"))
    

    @property
    def AVAILABILITY_HEURISTIC(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("AVAILABILITY_HEURISTIC"))
    

    @property
    def REPRESENTATIVENESS_HEURISTIC(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("REPRESENTATIVENESS_HEURISTIC"))
    

    

class RecommendationStrengthAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("RecommendationStrength")
        self._values: typing.Set[str] = set([ "FORTE",  "FRACA", ])
        self._vals = RecommendationStrengthValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "RecommendationStrengthValues":
        return self._vals


class RecommendationStrengthViewer(RecommendationStrengthAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class RecommendationStrengthValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def FORTE(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("FORTE"))
    

    @property
    def FRACA(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("FRACA"))
    

    

class ResearchSourceTypeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ResearchSourceType")
        self._values: typing.Set[str] = set([ "PUBMED",  "EUROPE_PMC",  "LENS_SCHOLARLY",  "WEB_SEARCH_BRAVE",  "COCHRANE",  "CLINICAL_TRIALS_GOV",  "ACADEMIC_GOOGLE_SCHOLAR",  "ACADEMIC_NCBI",  "ACADEMIC_ELITE_JOURNAL",  "ACADEMIC_DATABASE_GENERAL",  "GUIDELINE_RESOURCE",  "PREPRINT", ])
        self._vals = ResearchSourceTypeValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ResearchSourceTypeValues":
        return self._vals


class ResearchSourceTypeViewer(ResearchSourceTypeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class ResearchSourceTypeValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def PUBMED(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("PUBMED"))
    

    @property
    def EUROPE_PMC(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("EUROPE_PMC"))
    

    @property
    def LENS_SCHOLARLY(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("LENS_SCHOLARLY"))
    

    @property
    def WEB_SEARCH_BRAVE(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("WEB_SEARCH_BRAVE"))
    

    @property
    def COCHRANE(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("COCHRANE"))
    

    @property
    def CLINICAL_TRIALS_GOV(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("CLINICAL_TRIALS_GOV"))
    

    @property
    def ACADEMIC_GOOGLE_SCHOLAR(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("ACADEMIC_GOOGLE_SCHOLAR"))
    

    @property
    def ACADEMIC_NCBI(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("ACADEMIC_NCBI"))
    

    @property
    def ACADEMIC_ELITE_JOURNAL(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("ACADEMIC_ELITE_JOURNAL"))
    

    @property
    def ACADEMIC_DATABASE_GENERAL(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("ACADEMIC_DATABASE_GENERAL"))
    

    @property
    def GUIDELINE_RESOURCE(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("GUIDELINE_RESOURCE"))
    

    @property
    def PREPRINT(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("PREPRINT"))
    

    

class StudyDesignTypeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("StudyDesignType")
        self._values: typing.Set[str] = set([ "RCT",  "COHORT",  "CASE_CONTROL",  "CROSS_SECTIONAL",  "SYSTEMATIC_REVIEW",  "META_ANALYSIS",  "CASE_REPORT",  "REVIEW_ARTICLE",  "OTHER", ])
        self._vals = StudyDesignTypeValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "StudyDesignTypeValues":
        return self._vals


class StudyDesignTypeViewer(StudyDesignTypeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class StudyDesignTypeValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def RCT(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("RCT"))
    

    @property
    def COHORT(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("COHORT"))
    

    @property
    def CASE_CONTROL(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("CASE_CONTROL"))
    

    @property
    def CROSS_SECTIONAL(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("CROSS_SECTIONAL"))
    

    @property
    def SYSTEMATIC_REVIEW(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("SYSTEMATIC_REVIEW"))
    

    @property
    def META_ANALYSIS(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("META_ANALYSIS"))
    

    @property
    def CASE_REPORT(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("CASE_REPORT"))
    

    @property
    def REVIEW_ARTICLE(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("REVIEW_ARTICLE"))
    

    @property
    def OTHER(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("OTHER"))
    

    

class StudyTypeFilterAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("StudyTypeFilter")
        self._values: typing.Set[str] = set([ "ALL",  "SYSTEMATIC_REVIEW",  "RANDOMIZED_CONTROLLED_TRIAL",  "COHORT_STUDY",  "CASE_CONTROL",  "CLINICAL_TRIAL",  "REVIEW", ])
        self._vals = StudyTypeFilterValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "StudyTypeFilterValues":
        return self._vals


class StudyTypeFilterViewer(StudyTypeFilterAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class StudyTypeFilterValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def ALL(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("ALL"))
    

    @property
    def SYSTEMATIC_REVIEW(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("SYSTEMATIC_REVIEW"))
    

    @property
    def RANDOMIZED_CONTROLLED_TRIAL(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("RANDOMIZED_CONTROLLED_TRIAL"))
    

    @property
    def COHORT_STUDY(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("COHORT_STUDY"))
    

    @property
    def CASE_CONTROL(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("CASE_CONTROL"))
    

    @property
    def CLINICAL_TRIAL(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("CLINICAL_TRIAL"))
    

    @property
    def REVIEW(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("REVIEW"))
    

    

class UserRoleAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("UserRole")
        self._values: typing.Set[str] = set([ "PATIENT",  "DOCTOR_STUDENT", ])
        self._vals = UserRoleValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "UserRoleValues":
        return self._vals


class UserRoleViewer(UserRoleAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class UserRoleValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def PATIENT(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("PATIENT"))
    

    @property
    def DOCTOR_STUDENT(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("DOCTOR_STUDENT"))
    

    


__all__ = ["TypeBuilder"]